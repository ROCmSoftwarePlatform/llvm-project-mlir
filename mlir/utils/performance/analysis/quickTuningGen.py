import os
import sys
import argparse

import pulp
import numpy as np
import re
import glob
import pandas as pd
from sklearn.preprocessing import MinMaxScaler
from collections import defaultdict


class FileWriter():
    """
    A class to handle updating quick-tuning perfcofigs file.
    """

    def __init__(self, pargs):
        self.op = pargs.op
        self.arch = pargs.arch

    def parse_perfconfigs(self, perfconfig_str):
        """
        Parses a perfconfigs in expected input format
        """
        perfconfig_str = perfconfig_str.replace('v2:', '')
        config_values = perfconfig_str.split(',')
        total_values = len(config_values)
        converted_values = []
        for idx, value in enumerate(config_values):
            if idx > total_values - 3 and total_values == 9:
                if value == '1':
                    converted_values.append('true')
                else:
                    converted_values.append('false')
            else:
                converted_values.append(value)

        formated_perfconfig = ','.join(converted_values)
        return formated_perfconfig

    def replace_section(
            self,
            file_path,
            begin_marker,
            end_marker,
            new_content):
        """
        Replaces a section between the markers with new content
        """
        with open(file_path, 'r') as file:
            content = file.read()

        pattern = re.compile(f'{begin_marker}.*?{end_marker}', re.DOTALL)
        replacment = f'{begin_marker}\n{new_content}\n{end_marker}'
        content = pattern.sub(replacment, content)

        with open(file_path, 'w') as file:
            file.write(content)

    def is_accel(self, arch, datatype):
        instruction_type = self.get_instruction_type(arch, datatype)
        if instruction_type == "XDL" or instruction_type == "Wmma":
            return True
        else:
            return False

    def get_instruction_type(self, arch, datatype):
        """
        Determines the instruction type based on architecture and data type
        """
        if arch.startswith("gfx9"):
            return "XDL"
        elif arch.startswith("gfx1") and datatype != "f32":
            return "Wmma"
        else:
            return "NonAccel"

    def init_inc_file(self, file_path):
        """
        Initialize an .inc file with predefined structure
        """
        instruction_types_to_datatypes = {
            "NonAccel": ["f32"],
            "XDL": ["f32", "f16", "i8"],
            "Wmma": ["f16", "i8"]
        }
        markers = [
            "// BEGIN_GEMM",
            "// END_GEMM",
            "// BEGIN_CONV",
            "// END_CONV",
        ]

        with open(file_path, 'w') as file:
            file.write("// THIS IS AN AUTOGENERATED FILE.\n")
            file.write("// DO NOT EDIT THIS FILE DIRECTLY!\n\n")
            file.write("// clang-format off\n")
            for instruction_type, datatypes in instruction_types_to_datatypes.items():
                file.write(f"#ifdef {instruction_type}_DEFINITIONS_GEN\n\n")
                for datatype in datatypes:
                    for marker in markers:
                        file.write(
                            f"{marker}_{instruction_type}_{datatype}_DEFS\n\n")
                file.write(f"#endif\n\n")

                file.write(f"#ifdef {instruction_type}_DECLARATIONS_GEN\n\n")
                for datatype in datatypes:
                    for marker in markers:
                        file.write(
                            f"{marker}_{instruction_type}_{datatype}_DECS\n\n")
                file.write(f"#endif\n\n")

    def get_init_params_definitions(self, arch, dtype, op):
        """
        Generates initialization parameter definitions for a given data type and operation.
        """
        accel_type = 'Accel' if self.is_accel(arch, dtype) else 'NonAccel'
        instruction_type = self.get_instruction_type(arch, dtype)
        op_cap = op.capitalize()

        if dtype == 'f32':
            init_params = f"initParameters{op_cap}"
            n_init_params = f"nInitParameters{op_cap}"
            if not self.is_accel(arch, dtype):
                instruction_type = ''
        elif dtype == 'f16':
            init_params = f"initParametersFp16{op_cap}"
            n_init_params = f"nInitParametersFp16{op_cap}"
        elif dtype == 'i8' and op == 'conv':
            init_params = f"initParametersForward8Bit{op_cap}"
            n_init_params = f"nInitParametersForward8Bit{op_cap}"
        elif dtype == 'i8' and op == 'gemm':
            init_params = f"initParametersI8{op_cap}"
            n_init_params = f"nInitParametersI8{op_cap}"
        else:
            raise ValueError("Unsupported dtype")

        return f"const InitParams{accel_type} PopulateParams{instruction_type}::{init_params}[PopulateParams{instruction_type}::{n_init_params}]"

    def get_init_params_declaration(self, arch, dtype, op):
        """
        Generates initialization parameter declarations for a given data type and operation.
        """
        op_cap = op.capitalize()
        accel_type = 'Accel' if self.is_accel(arch, dtype) else 'NonAccel'

        if dtype == 'f32':
            init_params = f"initParameters{op_cap}"
            n_init_params = f"nInitParameters{op_cap}"
        elif dtype == 'f16':
            init_params = f"initParametersFp16{op_cap}"
            n_init_params = f"nInitParametersFp16{op_cap}"
        elif dtype == 'i8' and op == 'conv':
            init_params = f"initParametersForward8Bit{op_cap}"
            n_init_params = f"nInitParametersForward8Bit{op_cap}"
        elif dtype == 'i8' and op == 'gemm':
            init_params = f"initParametersI8{op_cap}"
            n_init_params = f"nInitParametersI8{op_cap}"
        else:
            raise ValueError("Unsupported dtype")

        return (f"static const InitParams{accel_type} {init_params}[{n_init_params}]",
                f"static constexpr size_t {n_init_params}")


    def update_config_file(self, result):
        """
        Updates the configuration file with selected perfconfigs
        """
        file_path = "../../../include/mlir/Dialect/Rock/Tuning/QuickTuningPerfconfigs.inc"
        if not os.path.exists(file_path):
            self.init_inc_file(file_path)

        datatype_names_defs= {
            'f32': self.get_init_params_definitions(self.arch, 'f32', self.op),
            'f16': self.get_init_params_definitions(self.arch, 'f16', self.op),
            'i8': self.get_init_params_definitions(self.arch, 'i8', self.op)
        }

        for datatype, perfconfigs in result.items():
            lines = []
            datatype_name = datatype_names_defs.get(datatype)
            lines.append(f"{datatype_name} = {{")
            for idx, perfconfig in enumerate(perfconfigs):
                formated_perfconfig = self.parse_perfconfigs(perfconfig)
                if idx == len(perfconfigs) - 1:
                    lines.append(f"    {{{formated_perfconfig}}}")
                else:
                    lines.append(f"    {{{formated_perfconfig}}},")
            lines.append("};")

            new_content = '\n'.join(lines)
            self.replace_section(
                file_path,
                f"// BEGIN_{self.op.upper()}_{self.get_instruction_type(self.arch, datatype)}_{datatype}_DEFS",
                f"// END_{self.op.upper()}_{self.get_instruction_type(self.arch, datatype)}_{datatype}_DEFS",
                new_content)

        datatype_names_decs = {}
        datatype_n_decs = {}

        for dtype in ['f32', 'f16', 'i8']:
            init_params_dec, n_params_dec = self.get_init_params_declaration(self.arch, dtype, self.op)
            datatype_names_decs[dtype] = init_params_dec
            datatype_n_decs[dtype] = n_params_dec

        for datatype, perfconfigs in result.items():
            lines = []
            datatype_name_dec = datatype_names_decs.get(datatype)
            datatype_n_dec = datatype_n_decs.get(datatype)
            lines.append(f"{datatype_n_dec} = {len(perfconfigs)};")
            lines.append(f"{datatype_name_dec};")

            new_content = '\n'.join(lines)
            self.replace_section(
                file_path,
                f"// BEGIN_{self.op.upper()}_{self.get_instruction_type(self.arch, datatype)}_{datatype}_DECS",
                f"// END_{self.op.upper()}_{self.get_instruction_type(self.arch, datatype)}_{datatype}_DECS",
                new_content)


class PerfConfigsFinder():
    """
    A class to find optimal perfconfigs based on input data
    """

    def __init__(self, combined_data, pargs):
        self.th = pargs.th
        self.op = pargs.op
        self.input_dir = pargs.input_dir
        self.arch = pargs.arch
        self.df = combined_data

    def get_unique_perfconfigs_list(self, problems_to_perfconfigs):
        """
        Return a unique list of perfconfigs from the provided dictonary
        """
        perfconfigs_set = set()
        for perfconfigs_lists in problems_to_perfconfigs.values():
            perfconfigs_set.update(perfconfigs_lists)
        return list(perfconfigs_set)

    def get_top_n_perfconfigs_per_problems(self, df, targetColumns):
        """
        Identifies the top perfconfigs for each problem based on a threshold
        """
        grouped = df.groupby(targetColumns)
        problem_df = {}
        for name, grouped_df in grouped:
            max_value = grouped_df['TFlops'].max()
            threshold = max_value * self.th
            problem_df[name] = grouped_df[grouped_df['TFlops']
                                          >= threshold]['PerfConfig']
        return problem_df

    def find(self):
        """
        Finds the minimal set of perfconfigs that cover all
        problems using set cover optimizaiton.
        Returns : A dictionary containing data types as keys and their
                  corresponding selected perfconfigs.
        """
        result = {}
        unique_data_types = self.df['DataType'].unique()

        targetColumns = []
        if self.op == "gemm":
            targetColumns = ['TransA', 'TransB', 'G', 'M', 'K', 'N']
        else:
            targetColumns = [
                'Direction',
                'InputLayout',
                'N',
                'C',
                'H',
                'W',
                'K',
                'Y',
                'X',
                'DilationH',
                'DilationW',
                'StrideH',
                'StrideW',
                'PaddingH',
                'PaddingW']

        for data_type in unique_data_types:
            df_typed = self.df[self.df['DataType'] == data_type]
            problems_to_perfconfigs = self.get_top_n_perfconfigs_per_problems(
                df_typed, targetColumns)

            problems = problems_to_perfconfigs.keys()
            perfconfigs = self.get_unique_perfconfigs_list(
                problems_to_perfconfigs)

            n = len(problems)
            m = len(perfconfigs)

            perfconfig_to_index = {perfconfig : idx for idx,
                                   perfconfig in enumerate(perfconfigs)}

            # Create coverage matrix
            A = np.zeros((n, m), dtype=int)
            for i, problem in enumerate(problems):
                for perfconfig in problems_to_perfconfigs[problem]:
                    j = perfconfig_to_index[perfconfig]
                    A[i][j] = 1

            # Linear programming model to minimize the number of perfconfigs
            prob = pulp.LpProblem("SetCoverProblems", pulp.LpMinimize)
            x = pulp.LpVariable.dicts("x", range(m), cat='Binary')
            # Set up objective function to minimize the sum of selected perfconfigs
            prob += pulp.lpSum([x[j]] for j in range(m))
            for i in range(n):
            # Add a constraint for each problem ensuring at least one perfconfig is selected
                prob += pulp.lpSum([A[i][j] * x[j]
                                   for j in range(m)]) >= 1, f"Cover_problem_{i}"

            prob.solve(pulp.PULP_CBC_CMD(msg=0))

            selected_configs = [perfconfigs[j]
                                for j in range(m) if x[j].varValue == 1]

            # Determine the number of problems covered by each selected perfcofing
            coverege_counts = {config: 0 for config in selected_configs}
            for i in range(n):
                for j in range(m):
                    if A[i][j] == 1 and x[j].varValue == 1:
                        coverege_counts[perfconfigs[j]] += 1

            # Sort selected perfconfigs by the number of problem they cover
            sorted_configs = sorted(selected_configs, key=lambda config: coverege_counts[config], reverse=True)

            result[data_type] = sorted_configs

        return result


def combine_data(input_dir, no_splitK):
    """
    Combine all *.debug tuning data into a single file.
    """
    tsv_files = glob.glob(os.path.join(input_dir, f"*.debug"))

    dfs = []
    for file in tsv_files:
        df = pd.read_csv(file, sep='\t', index_col=None)
        df = df[df.columns[1:]]
        dfs.append(df)
    if not dfs:
        return None
    new_df = pd.concat(dfs, ignore_index=True)

    # Remove splitK from tuning data
    if no_splitK:
        df_filtered = new_df[new_df['PerfConfig'].str.split(',').str[6] == '1']
        new_df = df_filtered

    return new_df


def print_results(result):
    """
    Print selected perfconfigs for each data type.
    """
    for datatype, perfconfings in result.items():
        print(f"Datatype: {datatype}")
        for idx, perfconfig in enumerate(perfconfings):
            print(f" {idx + 1}: {perfconfig}")


def main(args=None):
    """
    usage: quickTunerGen.py [-h] --input-dir INPUT_DIR --op {gemm,conv} [--th TH] --arch ARCH [--update] [--no-splitK]
    usage exsample: python3 quickTunerGen.py --input-dir tunedData --op conv --arch gfx90a --update --no-splitK
    """
    if args is None:
        args = sys.argv[1:]

    parser = argparse.ArgumentParser(prog='quickTunerGen.py')

    parser.add_argument('--input-dir',
                        required=True,
                        type=str)

    parser.add_argument('--op',
                        required=True,
                        type=str,
                        choices=["gemm", "conv"])

    parser.add_argument("--th",
                        required=False,
                        type=float,
                        default=0.93)

    parser.add_argument("--arch",
                        required=True,
                        type=str)

    parser.add_argument("--update",
                        required=False,
                        default=False,
                        action='store_true')

    parser.add_argument(
        '--no-splitK',
        default=False,
        action='store_true',
        help='Removing the spliK factor from the generated list')

    pargs = parser.parse_args()

    combined_data = combine_data(pargs.input_dir, pargs.no_splitK)

    finder = PerfConfigsFinder(combined_data, pargs)
    result = finder.find()

    print_results(result)

    file_writer = FileWriter(pargs)
    if pargs.update:
        file_writer.update_config_file(result)


if __name__ == '__main__':
    main(sys.argv[1:])
