// RUN: rocmlir-opt -rock-output-swizzle %s | FileCheck %s

#wg = #gpu.address_space<workgroup>
#priv = #gpu.address_space<private>

// CHECK-LABEL: func.func @rock_output_swizzle
func.func @rock_output_swizzle(%matrix_c: memref<1x1280x2048xf16>) attributes{arch = "", block_size = 256 : i32, grid_size = 320 : i32, kernel} {
  %registers = rock.alloc() : memref<32xf16, #priv>
  %registers2 = rock.alloc() : memref<32xf16, #priv>
  %blockid = rock.workgroup_id : index
  %threadid = rock.workitem_id : index

  %c22 = arith.constant 22 : index
  %c320 = arith.constant 320 : index
  %c20 = arith.constant 20 : index
  %c352 = arith.constant 352 : index
  %16 = arith.divui %blockid, %c320 : index
  %17 = arith.remui %blockid, %c320 : index
  %18 = arith.divui %17, %c352 : index
  %19 = arith.muli %18, %c22 : index
  %20 = arith.subi %c20, %19 : index
  %21 = arith.minui %20, %c22 : index
  %22 = arith.remui %17, %21 : index
  %23 = arith.addi %19, %22 : index
  %24 = arith.remui %17, %c352 : index
  %25 = arith.divui %24, %21 : index

  %28 = rock.alloc() : memref<16384xi8, #wg>
  %29 = rock.alloc() : memref<16384xi8, #wg>
  
  %c0 = arith.constant 0 : index
  %view_29 = memref.view %29[%c0][] : memref<16384xi8, #wg> to memref<8192xf16, #wg>
  %view_29_2 = rock.transform %view_29 by <affine_map<(d0, d1, d2) -> ((d1 * 256 + d0) * 8 + d2)> by [<Unmerge{4, 256, 8} ["iter", "tid", "numElements"] at [1, 0, 2] -> ["flattenBlock"] at [0]>] bounds = [256, 4, 8] -> [8192]> : memref<8192xf16, #gpu.address_space<workgroup>> to memref<256x4x8xf16, #gpu.address_space<workgroup>>
  %view_29_3 = rock.transform %view_29_2 by <affine_map<(d0, d1) -> (d0, d1 floordiv 8, d1 mod 8)> by [<PassThrough ["tid"] at [0] -> ["tid"] at [0]>, <Merge{4, 8} ["iter"] at [1] -> ["iter", "numElements"] at [1, 2]>] bounds = [256, 32] -> [256, 4, 8]> : memref<256x4x8xf16, #gpu.address_space<workgroup>> to memref<256x32xf16, #gpu.address_space<workgroup>>
  rock.threadwise_read_into {forceUnroll, useIndexDiffs} [](%view_29_3) [%threadid] -> %registers : memref<256x32xf16, #wg> -> memref<32xf16, #priv>
  rock.dealloc %29 : memref<16384xi8, #wg>

  %view_28 = memref.view %28[%c0][] : memref<16384xi8, #wg> to memref<8192xf16, #wg>
  %view_28_2 = rock.transform %view_28 by <affine_map<(d0, d1, d2) -> ((d1 * 256 + d0) * 8 + d2)> by [<Unmerge{4, 256, 8} ["iter", "tid", "numElements"] at [1, 0, 2] -> ["flattenBlock"] at [0]>] bounds = [256, 4, 8] -> [8192]> : memref<8192xf16, #gpu.address_space<workgroup>> to memref<256x4x8xf16, #gpu.address_space<workgroup>>
  %view_28_3 = rock.transform %view_28_2 by <affine_map<(d0, d1) -> (d0, d1 floordiv 8, d1 mod 8)> by [<PassThrough ["tid"] at [0] -> ["tid"] at [0]>, <Merge{4, 8} ["iter"] at [1] -> ["iter", "numElements"] at [1, 2]>] bounds = [256, 32] -> [256, 4, 8]> : memref<256x4x8xf16, #gpu.address_space<workgroup>> to memref<256x32xf16, #gpu.address_space<workgroup>>
  rock.threadwise_read_into {forceUnroll, useIndexDiffs} [](%view_28_3) [%threadid] -> %registers2 : memref<256x32xf16, #wg> -> memref<32xf16, #priv>
  rock.dealloc %28 : memref<16384xi8, #wg>
  
  // add registers
  %load = rock.in_bounds_load %registers[%c0] : memref<32xf16, #priv>, index -> vector<32xf16>
  %load2 = rock.in_bounds_load %registers2[%c0] : memref<32xf16, #priv>, index -> vector<32xf16>
  %add = arith.addf %load, %load2 : vector<32xf16>
  rock.in_bounds_store %add -> %registers[%c0] : vector<32xf16> -> memref<32xf16, #priv>, index

  // CHECK: rock.alloc() : memref<16384xi8, #gpu.address_space<workgroup>>
  // CHECK: rock.threadwise_write_all
  // CHECK: rock.lds_barrier
  // CHECK: rock.threadwise_read_into
  // CHECK: rock.threadwise_write_all
  rock.threadwise_write_all features =  mfma|dot|atomic_add|atomic_add_f16 {forceUnroll, useIndexDiffs} %registers -> [#rock.transform_map<affine_map<(d0, d1, d2, d3, d4) -> (d0, d1, d2, d3 floordiv 64, (d3 mod 64) floordiv 32, d3 mod 32, d4 floordiv 16, 0, (d4 mod 16) floordiv 4, d4 mod 4)> by [<PassThrough ["g_block", "m_block", "n_block"] at [0, 1, 2] -> ["g_block", "m_block", "n_block"] at [0, 1, 2]>, <Merge{4, 2, 32} ["tid"] at [3] -> ["wave", "m_tid", "n_tid"] at [3, 4, 5]>, <Merge{2, 1, 4, 4} ["item"] at [4] -> ["i", "j", "vec_group", "vec_item"] at [6, 7, 8, 9]>] bounds = [1, 20, 16, 256, 32] -> [1, 20, 16, 4, 2, 32, 2, 1, 4, 4]>, #rock.transform_map<affine_map<(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9) -> (d0, d1, d2, d3 floordiv 2, d3 mod 2, d4, d5, 0, d6, 0, 0, d8, d9)> by [<PassThrough ["g_block", "m_block", "n_block"] at [0, 1, 2] -> ["g_block", "m_block", "n_block"] at [0, 1, 2]>, <Merge{2, 2} ["wave"] at [3] -> ["wave_m", "wave_n"] at [3, 4]>, <PassThrough ["m_tid", "n_tid"] at [4, 5] -> ["m_tid", "n_tid"] at [5, 6]>, <Merge{1, 2} ["i"] at [6] -> ["m_i", "n_i"] at [7, 8]>, <Merge{1, 1} ["j"] at [7] -> ["blk_row", "blk_col"] at [9, 10]>, <PassThrough ["vec_group", "vec_item"] at [8, 9] -> ["vec_group", "vec_item"] at [11, 12]>] bounds = [1, 20, 16, 4, 2, 32, 2, 1, 4, 4] -> [1, 20, 16, 2, 2, 2, 32, 1, 2, 1, 1, 4, 4]>, #rock.transform_map<affine_map<(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12) -> (d0, ((((d1 + d7) * 2 + d3 + d9) * 4 + d11) * 2 + d5) * 4 + d12, ((d2 * 2 + d8) * 2 + d4 + d10) * 32 + d6)> by [<PassThrough ["g_block"] at [0] -> ["gemmG"] at [0]>, <Unmerge{20, 1, 2, 1, 4, 2, 4} ["m_block", "m_i", "wave_m", "blk_row", "vec_group", "m_tid", "vec_item"] at [1, 7, 3, 9, 11, 5, 12] -> ["gemmM"] at [1]>, <Unmerge{16, 2, 2, 1, 32} ["n_block", "n_i", "wave_n", "blk_col", "n_tid"] at [2, 8, 4, 10, 6] -> ["gemmN"] at [2]>] bounds = [1, 20, 16, 2, 2, 2, 32, 1, 2, 1, 1, 4, 4] -> [1, 1280, 2048]>, #rock.transform_map<affine_map<(d0, d1, d2) -> (d0, d1, d2)> by [<PassThrough ["gemmG"] at [0] -> ["gemmG"] at [0]>, <PassThrough ["gemmM"] at [1] -> ["gemmM"] at [1]>, <PassThrough ["gemmN"] at [2] -> ["gemmN"] at [2]>] bounds = [1, 1280, 2048] -> [1, 1280, 2048]>, #rock.transform_map<affine_map<(d0, d1, d2) -> (d0, d1, d2)> by [<PassThrough ["gemmG"] at [0] -> ["gemmG"] at [0]>, <PassThrough ["gemmM"] at [1] -> ["gemmM"] at [1]>, <PassThrough ["gemmN"] at [2] -> ["gemmN"] at [2]>] bounds = [1, 1280, 2048] -> [1, 1280, 2048]>](%matrix_c) [%16, %23, %25, %threadid] by  set : memref<32xf16, #gpu.address_space<private>> -> memref<1x1280x2048xf16>
  return
}

// CHECK-LABEL: func.func @rock_output_swizzle_multiple_outputs
func.func @rock_output_swizzle_multiple_outputs(%arg0: memref<1280xf16> {mhal.read_access}, %arg1: memref<5242880xf16> {mhal.read_access}, %arg2: memref<819200xf16> {mhal.read_access}, %arg3: memref<10485760xf16> {mhal.write_access}, %arg4: memref<10485760xf16> {mhal.write_access}) attributes {arch = "gfx90a:sramecc+:xnack-", block_size = 256 : i32, grid_size = 2560 : i32, kernel, original_func = @test} {
  %0 = rock.alloc() : memref<8192xi8, #gpu.address_space<workgroup>>
  %1 = rock.alloc() : memref<8192xi8, #gpu.address_space<workgroup>>
  %c9 = arith.constant 9 : index
  %c1 = arith.constant 1 : index
  %cst = arith.constant dense<0.000000e+00> : vector<16xf32>
  %c2560 = arith.constant 2560 : index
  %c20 = arith.constant 20 : index
  %c2816 = arith.constant 2816 : index
  %c22 = arith.constant 22 : index
  %c0 = arith.constant 0 : index
  %2 = rock.transform %arg0 by <affine_map<(d0, d1, d2, d3) -> (d0 + d1 + d2 + d3)> by [<Unmerge{1280, 1, 1, 1} ["exp0", "exp1", "exp2", "exp3"] at [0, 1, 2, 3] -> ["dim0"] at [0]>] bounds = [1280, 1, 1, 1] -> [1280]> : memref<1280xf16> to memref<1280x1x1x1xf16>
  %3 = rock.transform %2 by <affine_map<(d0, d1, d2, d3) -> (d1, d2, d3, d0)> by [<PassThrough ["dim3", "dim0", "dim1", "dim2"] at [0, 1, 2, 3] -> ["dim3", "dim0", "dim1", "dim2"] at [3, 0, 1, 2]>] bounds = [1, 1280, 1, 1] -> [1280, 1, 1, 1]> : memref<1280x1x1x1xf16> to memref<1x1280x1x1xf16>
  %4 = rock.transform %3 by <affine_map<(d0, d1, d2, d3) -> (0, d1, 0, 0)> by [<Broadcast{1} ["dim0"] at [0] -> ["dim0"] at [0]>, <PassThrough ["dim1"] at [1] -> ["dim1"] at [1]>, <Broadcast{1} ["dim2"] at [2] -> ["dim2"] at [2]>, <Broadcast{1} ["dim3"] at [3] -> ["dim3"] at [3]>] bounds = [2, 1280, 64, 64] -> [1, 1280, 1, 1]> : memref<1x1280x1x1xf16> to memref<2x1280x64x64xf16>
  %5 = rock.transform %arg2 by <affine_map<(d0, d1, d2, d3) -> (((d0 + d1) * 1280 + d2) * 640 + d3)> by [<Unmerge{1, 1, 1280, 640} ["exp0", "exp1", "exp2", "exp3"] at [0, 1, 2, 3] -> ["dim0"] at [0]>] bounds = [1, 1, 1280, 640] -> [819200]> : memref<819200xf16> to memref<1x1x1280x640xf16>
  %6 = rock.transform %arg1 by <affine_map<(d0, d1, d2, d3) -> (((d0 * 64 + d1) * 64 + d2) * 640 + d3)> by [<Unmerge{2, 64, 64, 640} ["exp0", "exp1", "exp2", "exp3"] at [0, 1, 2, 3] -> ["dim0"] at [0]>] bounds = [2, 64, 64, 640] -> [5242880]> : memref<5242880xf16> to memref<2x64x64x640xf16>
  %7 = rock.transform %6 by <affine_map<(d0, d1, d2, d3, d4) -> (d0, d1, d2, d3 * 640 + d4)> by [<PassThrough ["n", "h", "w"] at [0, 1, 2] -> ["n", "h", "w"] at [0, 1, 2]>, <Unmerge{1, 640} ["g", "c"] at [3, 4] -> ["c"] at [3]>] bounds = [2, 64, 64, 1, 640] -> [2, 64, 64, 640]> : memref<2x64x64x640xf16> to memref<2x64x64x1x640xf16>
  %8 = rock.transform %5 by <affine_map<(d0, d1, d2, d3, d4) -> (d0, d1, d2 * 1280 + d3, d4)> by [<PassThrough ["y", "x", "c"] at [0, 1, 4] -> ["y", "x", "c"] at [0, 1, 3]>, <Unmerge{1, 1280} ["g", "k"] at [2, 3] -> ["k"] at [2]>] bounds = [1, 1, 1, 1280, 640] -> [1, 1, 1280, 640]> : memref<1x1x1280x640xf16> to memref<1x1x1x1280x640xf16>
  %9 = rock.transform %8 by <affine_map<(d0, d1, d2) -> (0, 0, d0, d2, d1)> by [<PassThrough ["gemmG"] at [0] -> ["g"] at [2]>, <Merge{1, 1, 640} ["gemmK"] at [1] -> ["0", "1", "c"] at [0, 1, 4]>, <PassThrough ["gemmM"] at [2] -> ["k"] at [3]>] bounds = [1, 640, 1280] -> [1, 1, 1, 1280, 640]> : memref<1x1x1x1280x640xf16> to memref<1x640x1280xf16>
  %10 = rock.transform %7 by <affine_map<(d0, d1, d2, d3, d4) -> (d0, d1, d2, d3, d4)> by [<PassThrough ["ni"] at [0] -> ["ni"] at [0]>, <PassThrough ["gi"] at [3] -> ["gi"] at [3]>, <PassThrough ["ci"] at [4] -> ["ci"] at [4]>, <Pad{0, 0, 0, 0} ["0ipad", "1ipad"] at [1, 2] -> ["0i", "1i"] at [1, 2]>] bounds = [2, 64, 64, 1, 640] -> [2, 64, 64, 1, 640]> : memref<2x64x64x1x640xf16> to memref<2x64x64x1x640xf16>
  %11 = rock.transform %10 by <affine_map<(d0, d1, d2, d3, d4, d5, d6) -> (d0, d2, d4, d5, d6)> by [<PassThrough ["ni", "gi", "ci"] at [0, 5, 6] -> ["ni", "gi", "ci"] at [0, 3, 4]>, <AddDim{1} ["0"] at [1] -> [] at []>, <PassThrough ["0o"] at [2] -> ["0ipad"] at [1]>, <AddDim{1} ["1"] at [3] -> [] at []>, <PassThrough ["1o"] at [4] -> ["1ipad"] at [2]>] bounds = [2, 1, 64, 1, 64, 1, 640] -> [2, 64, 64, 1, 640]> : memref<2x64x64x1x640xf16> to memref<2x1x64x1x64x1x640xf16>
  %12 = rock.transform %11 by <affine_map<(d0, d1, d2) -> (d2 floordiv 4096, 0, (d2 mod 4096) floordiv 64, 0, d2 mod 64, d0, d1)> by [<PassThrough ["gemmG"] at [0] -> ["gi"] at [5]>, <Merge{1, 1, 640} ["gemmK"] at [1] -> ["0", "1", "ci"] at [1, 3, 6]>, <Merge{2, 64, 64} ["gemmN"] at [2] -> ["ni", "0o", "1o"] at [0, 2, 4]>] bounds = [1, 640, 8192] -> [2, 1, 64, 1, 64, 1, 640]> : memref<2x1x64x1x64x1x640xf16> to memref<1x640x8192xf16>
  %13 = rock.transform %9 by <affine_map<(d0, d1, d2, d3, d4, d5, d6, d7) -> (d1, (d0 * 8 + d5) * 8 + d7, (d2 * 32 + d4) * 2 + d6)> by [<PassThrough ["g_block"] at [1] -> ["g"] at [0]>, <Unmerge{10, 8, 8} ["k_loop", "k_thread", "k_iter"] at [0, 5, 7] -> ["k"] at [1]>, <Unmerge{20, 32, 2} ["m_block", "m_thread", "m_iter"] at [2, 4, 6] -> ["m"] at [2]>, <AddDim{128} ["n_block"] at [3] -> [] at []>] bounds = [10, 1, 20, 128, 32, 8, 2, 8] -> [1, 640, 1280]> : memref<1x640x1280xf16> to memref<10x1x20x128x32x8x2x8xf16>
  %14 = rock.transform %13 by <affine_map<(d0, d1, d2, d3, d4, d5) -> (d0, d1, d2, d3, d4 floordiv 8, d4 mod 8, d5 floordiv 8, d5 mod 8)> by [<PassThrough ["k_loop", "g_block", "m_block", "n_block"] at [0, 1, 2, 3] -> ["k_loop", "g_block", "m_block", "n_block"] at [0, 1, 2, 3]>, <Merge{32, 8} ["tid"] at [4] -> ["m_thread", "k_thread"] at [4, 5]>, <Merge{2, 8} ["iter"] at [5] -> ["m_iter", "k_iter"] at [6, 7]>] bounds = [10, 1, 20, 128, 256, 16] -> [10, 1, 20, 128, 32, 8, 2, 8]> : memref<10x1x20x128x32x8x2x8xf16> to memref<10x1x20x128x256x16xf16>
  %15 = rock.transform %12 by <affine_map<(d0, d1, d2, d3, d4, d5, d6, d7) -> (d1, (d0 * 8 + d5) * 8 + d7, (d3 * 32 + d4) * 2 + d6)> by [<PassThrough ["g_block"] at [1] -> ["g"] at [0]>, <Unmerge{10, 8, 8} ["k_loop", "k_thread", "k_iter"] at [0, 5, 7] -> ["k"] at [1]>, <Unmerge{128, 32, 2} ["n_block", "n_thread", "n_iter"] at [3, 4, 6] -> ["n"] at [2]>, <AddDim{20} ["m_block"] at [2] -> [] at []>] bounds = [10, 1, 20, 128, 32, 8, 2, 8] -> [1, 640, 8192]> : memref<1x640x8192xf16> to memref<10x1x20x128x32x8x2x8xf16>
  %16 = rock.transform %15 by <affine_map<(d0, d1, d2, d3, d4, d5) -> (d0, d1, d2, d3, d4 floordiv 8, d4 mod 8, d5 floordiv 8, d5 mod 8)> by [<PassThrough ["k_loop", "g_block", "m_block", "n_block"] at [0, 1, 2, 3] -> ["k_loop", "g_block", "m_block", "n_block"] at [0, 1, 2, 3]>, <Merge{32, 8} ["tid"] at [4] -> ["n_thread", "k_thread"] at [4, 5]>, <Merge{2, 8} ["iter"] at [5] -> ["n_iter", "k_iter"] at [6, 7]>] bounds = [10, 1, 20, 128, 256, 16] -> [10, 1, 20, 128, 32, 8, 2, 8]> : memref<10x1x20x128x32x8x2x8xf16> to memref<10x1x20x128x256x16xf16>
  %17 = rock.workgroup_id : index
  %18 = rock.workitem_id : index
  %19 = rock.alloc() : memref<16xf16, #gpu.address_space<private>>
  %20 = rock.alloc() : memref<16xf16, #gpu.address_space<private>>
  %21 = arith.divui %17, %c2560 : index
  %22 = arith.remui %17, %c2560 : index
  %23 = arith.divui %22, %c2816 : index
  %24 = arith.muli %23, %c22 : index
  %25 = arith.subi %c20, %24 : index
  %26 = arith.minui %25, %c22 : index
  %27 = arith.remui %22, %26 : index
  %28 = arith.addi %24, %27 : index
  %29 = arith.remui %22, %c2816 : index
  %30 = arith.divui %29, %26 : index
  %31 = rock.alloc() : memref<16xf16, #gpu.address_space<private>>
  %32 = rock.alloc() : memref<16xf16, #gpu.address_space<private>>
  %33 = rock.transform %19 by <affine_map<(d0, d1) -> (d0 * 8 + d1)> by [<Unmerge{2, 8} ["m_iter", "k_iter"] at [0, 1] -> ["iter"] at [0]>] bounds = [2, 8] -> [16]> : memref<16xf16, #gpu.address_space<private>> to memref<2x8xf16, #gpu.address_space<private>>
  %34 = rock.transform %33 by <affine_map<(d0, d1) -> (d1, d0)> by [<Merge{8} ["k"] at [0] -> ["k_iter"] at [1]>, <Merge{2} ["m"] at [1] -> ["m_iter"] at [0]>] bounds = [8, 2] -> [2, 8]> : memref<2x8xf16, #gpu.address_space<private>> to memref<8x2xf16, #gpu.address_space<private>>
  %35 = rock.transform %31 by <affine_map<(d0, d1, d2) -> ((d0 * 2 + d1) * 8 + d2)> by [<Unmerge{1, 2, 8} ["kouterPerThread", "m_iter", "kpackPerThread"] at [0, 1, 2] -> ["iter"] at [0]>] bounds = [1, 2, 8] -> [16]> : memref<16xf16, #gpu.address_space<private>> to memref<1x2x8xf16, #gpu.address_space<private>>
  %36 = rock.transform %35 by <affine_map<(d0, d1) -> (0, d1, d0)> by [<Merge{1, 8} ["k"] at [0] -> ["kouterPerThread", "kpackPerThread"] at [0, 2]>, <Merge{2} ["m"] at [1] -> ["m_iter"] at [1]>] bounds = [8, 2] -> [1, 2, 8]> : memref<1x2x8xf16, #gpu.address_space<private>> to memref<8x2xf16, #gpu.address_space<private>>
  %37 = rock.transform %20 by <affine_map<(d0, d1) -> (d0 * 8 + d1)> by [<Unmerge{2, 8} ["n_iter", "k_iter"] at [0, 1] -> ["iter"] at [0]>] bounds = [2, 8] -> [16]> : memref<16xf16, #gpu.address_space<private>> to memref<2x8xf16, #gpu.address_space<private>>
  %38 = rock.transform %37 by <affine_map<(d0, d1) -> (d1, d0)> by [<Merge{8} ["k"] at [0] -> ["k_iter"] at [1]>, <Merge{2} ["n"] at [1] -> ["n_iter"] at [0]>] bounds = [8, 2] -> [2, 8]> : memref<2x8xf16, #gpu.address_space<private>> to memref<8x2xf16, #gpu.address_space<private>>
  %39 = rock.transform %32 by <affine_map<(d0, d1, d2) -> ((d0 * 2 + d1) * 8 + d2)> by [<Unmerge{1, 2, 8} ["kouterPerThread", "n_iter", "kpackPerThread"] at [0, 1, 2] -> ["iter"] at [0]>] bounds = [1, 2, 8] -> [16]> : memref<16xf16, #gpu.address_space<private>> to memref<1x2x8xf16, #gpu.address_space<private>>
  %40 = rock.transform %39 by <affine_map<(d0, d1) -> (0, d1, d0)> by [<Merge{1, 8} ["k"] at [0] -> ["kouterPerThread", "kpackPerThread"] at [0, 2]>, <Merge{2} ["n"] at [1] -> ["n_iter"] at [1]>] bounds = [8, 2] -> [1, 2, 8]> : memref<1x2x8xf16, #gpu.address_space<private>> to memref<8x2xf16, #gpu.address_space<private>>
  %c0_0 = arith.constant 0 : index
  %view = memref.view %0[%c0_0][] : memref<8192xi8, #gpu.address_space<workgroup>> to memref<8192xi8, #gpu.address_space<workgroup>>
  %c0_1 = arith.constant 0 : index
  %view_2 = memref.view %1[%c0_1][] : memref<8192xi8, #gpu.address_space<workgroup>> to memref<8192xi8, #gpu.address_space<workgroup>>
  %view_3 = memref.view %view[%c0][] : memref<8192xi8, #gpu.address_space<workgroup>> to memref<512xvector<8xf16>, #gpu.address_space<workgroup>>
  %view_4 = memref.view %view_2[%c0][] : memref<8192xi8, #gpu.address_space<workgroup>> to memref<512xvector<8xf16>, #gpu.address_space<workgroup>>
  %view_5 = memref.view %view[%c0][] : memref<8192xi8, #gpu.address_space<workgroup>> to memref<512xvector<8xf16>, #gpu.address_space<workgroup>>
  %view_6 = memref.view %view_2[%c0][] : memref<8192xi8, #gpu.address_space<workgroup>> to memref<512xvector<8xf16>, #gpu.address_space<workgroup>>
  %41 = rock.alloc() : memref<8xvector<4xf16>, #gpu.address_space<private>>
  %42 = rock.alloc() : memref<8xvector<4xf16>, #gpu.address_space<private>>
  %43 = rock.alloc() : memref<1xvector<16xf32>, #gpu.address_space<private>>
  affine.for %arg5 = 0 to 1 {
    memref.store %cst, %43[%arg5] : memref<1xvector<16xf32>, #gpu.address_space<private>>
  }
  %44 = rock.threadwise_read_into {forceUnroll, useIndexDiffs} [](%14) [%c0, %21, %28, %30, %18] -> %19 : memref<10x1x20x128x256x16xf16> -> memref<16xf16, #gpu.address_space<private>>, vector<16xi1>
  %45 = rock.threadwise_read_into {forceUnroll, useIndexDiffs} [](%16) [%c0, %21, %28, %30, %18] -> %20 : memref<10x1x20x128x256x16xf16> -> memref<16xf16, #gpu.address_space<private>>, vector<16xi1>
  rock.threadwise_copy %34 -> %36 : memref<8x2xf16, #gpu.address_space<private>> -> memref<8x2xf16, #gpu.address_space<private>>
  rock.threadwise_copy %38 -> %40 : memref<8x2xf16, #gpu.address_space<private>> -> memref<8x2xf16, #gpu.address_space<private>>
  %46 = rock.extract_multibuffer(%view_3) [%c0](memref<512xvector<8xf16>, #gpu.address_space<workgroup>>) : memref<512xvector<8xf16>, #gpu.address_space<workgroup>>
  %47 = rock.transform %46 by <affine_map<(d0, d1, d2, d3) -> (d0 * 64 + d1 + d2)> by [<Unmerge{8, 64, 1} ["k_outer", "m", "kpack_idx"] at [0, 1, 2] -> ["raw"] at [0]>, <AddDim{8} ["kpack_vec"] at [3] -> [] at []>] bounds = [8, 64, 1, 8] -> [512]> : memref<512xvector<8xf16>, #gpu.address_space<workgroup>> to memref<8x64x1x8xvector<8xf16>, #gpu.address_space<workgroup>>
  %48 = rock.transform %47 by <affine_map<(d0, d1, d2, d3) -> (d0, d1 mod 64, d2, d3)> by [<PassThrough ["k_outer"] at [0] -> ["k_outer"] at [0]>, <Broadcast{64} ["m"] at [1] -> ["m"] at [1]>, <PassThrough ["kpack_idx", "kpack_vec"] at [2, 3] -> ["kpack_idx", "kpack_vec"] at [2, 3]>] bounds = [8, 512, 1, 8] -> [8, 64, 1, 8]> : memref<8x64x1x8xvector<8xf16>, #gpu.address_space<workgroup>> to memref<8x512x1x8xvector<8xf16>, #gpu.address_space<workgroup>>
  %49 = rock.transform %48 by <affine_map<(d0, d1, d2, d3) -> (d0, d0 + d1, d2, d3)> by [<PassThrough ["k_outer"] at [0] -> ["k_outer"] at [0]>, <Embed{1, 1} ["k_outer", "m"] at [0, 1] -> ["m"] at [1]>, <PassThrough ["kpack_idx", "kpack_vec"] at [2, 3] -> ["kpack_idx", "kpack_vec"] at [2, 3]>] bounds = [8, 64, 1, 8] -> [8, 512, 1, 8]> : memref<8x512x1x8xvector<8xf16>, #gpu.address_space<workgroup>> to memref<8x64x1x8xvector<8xf16>, #gpu.address_space<workgroup>>
  %50 = rock.transform %49 by <affine_map<(d0, d1) -> (d0 floordiv 8, d1, 0, d0 mod 8)> by [<Merge{8, 1, 8} ["k"] at [0] -> ["k_outer", "kpack_idx", "kpack_vec"] at [0, 2, 3]>, <Merge{64} ["d"] at [1] -> ["m"] at [1]>] bounds = [64, 64] -> [8, 64, 1, 8]> : memref<8x64x1x8xvector<8xf16>, #gpu.address_space<workgroup>> to memref<64x64xvector<8xf16>, #gpu.address_space<workgroup>>
  %51 = rock.transform %50 by <affine_map<(d0, d1, d2, d3, d4) -> ((d1 + d2) * 8 + d4, d0 * 2 + d3)> by [<Unmerge{8, 1, 8} ["k_thread", "kouterPerThread", "kpackPerThread"] at [1, 2, 4] -> ["k"] at [0]>, <Unmerge{32, 2} ["m_thread", "m_iter"] at [0, 3] -> ["m"] at [1]>] bounds = [32, 8, 1, 2, 8] -> [64, 64]> : memref<64x64xvector<8xf16>, #gpu.address_space<workgroup>> to memref<32x8x1x2x8xvector<8xf16>, #gpu.address_space<workgroup>>
  %52 = rock.transform %51 by <affine_map<(d0, d1) -> (d0 floordiv 8, d0 mod 8, 0, d1 floordiv 8, d1 mod 8)> by [<Merge{32, 8} ["tid"] at [0] -> ["m_thread", "k_thread"] at [0, 1]>, <Merge{1, 2, 8} ["iter"] at [1] -> ["kouterPerThread", "m_iter", "kpackPerThread"] at [2, 3, 4]>] bounds = [256, 16] -> [32, 8, 1, 2, 8]> : memref<32x8x1x2x8xvector<8xf16>, #gpu.address_space<workgroup>> to memref<256x16xvector<8xf16>, #gpu.address_space<workgroup>>
  rock.threadwise_write_all features =  mfma|dot|atomic_add|atomic_add_f16 {forceUnroll, useIndexDiffs} %31 -> [](%52) [%18] by  set : memref<16xf16, #gpu.address_space<private>> -> memref<256x16xvector<8xf16>, #gpu.address_space<workgroup>>
  %53 = rock.extract_multibuffer(%view_4) [%c0](memref<512xvector<8xf16>, #gpu.address_space<workgroup>>) : memref<512xvector<8xf16>, #gpu.address_space<workgroup>>
  %54 = rock.transform %53 by <affine_map<(d0, d1, d2, d3) -> (d0 * 64 + d1 + d2)> by [<Unmerge{8, 64, 1} ["k_outer", "n", "kpack_idx"] at [0, 1, 2] -> ["raw"] at [0]>, <AddDim{8} ["kpack_vec"] at [3] -> [] at []>] bounds = [8, 64, 1, 8] -> [512]> : memref<512xvector<8xf16>, #gpu.address_space<workgroup>> to memref<8x64x1x8xvector<8xf16>, #gpu.address_space<workgroup>>
  %55 = rock.transform %54 by <affine_map<(d0, d1, d2, d3) -> (d0, d1 mod 64, d2, d3)> by [<PassThrough ["k_outer"] at [0] -> ["k_outer"] at [0]>, <Broadcast{64} ["n"] at [1] -> ["n"] at [1]>, <PassThrough ["kpack_idx", "kpack_vec"] at [2, 3] -> ["kpack_idx", "kpack_vec"] at [2, 3]>] bounds = [8, 512, 1, 8] -> [8, 64, 1, 8]> : memref<8x64x1x8xvector<8xf16>, #gpu.address_space<workgroup>> to memref<8x512x1x8xvector<8xf16>, #gpu.address_space<workgroup>>
  %56 = rock.transform %55 by <affine_map<(d0, d1, d2, d3) -> (d0, d0 + d1, d2, d3)> by [<PassThrough ["k_outer"] at [0] -> ["k_outer"] at [0]>, <Embed{1, 1} ["k_outer", "n"] at [0, 1] -> ["n"] at [1]>, <PassThrough ["kpack_idx", "kpack_vec"] at [2, 3] -> ["kpack_idx", "kpack_vec"] at [2, 3]>] bounds = [8, 64, 1, 8] -> [8, 512, 1, 8]> : memref<8x512x1x8xvector<8xf16>, #gpu.address_space<workgroup>> to memref<8x64x1x8xvector<8xf16>, #gpu.address_space<workgroup>>
  %57 = rock.transform %56 by <affine_map<(d0, d1) -> (d0 floordiv 8, d1, 0, d0 mod 8)> by [<Merge{8, 1, 8} ["k"] at [0] -> ["k_outer", "kpack_idx", "kpack_vec"] at [0, 2, 3]>, <Merge{64} ["d"] at [1] -> ["n"] at [1]>] bounds = [64, 64] -> [8, 64, 1, 8]> : memref<8x64x1x8xvector<8xf16>, #gpu.address_space<workgroup>> to memref<64x64xvector<8xf16>, #gpu.address_space<workgroup>>
  %58 = rock.transform %57 by <affine_map<(d0, d1, d2, d3, d4) -> ((d1 + d2) * 8 + d4, d0 * 2 + d3)> by [<Unmerge{8, 1, 8} ["k_thread", "kouterPerThread", "kpackPerThread"] at [1, 2, 4] -> ["k"] at [0]>, <Unmerge{32, 2} ["n_thread", "n_iter"] at [0, 3] -> ["n"] at [1]>] bounds = [32, 8, 1, 2, 8] -> [64, 64]> : memref<64x64xvector<8xf16>, #gpu.address_space<workgroup>> to memref<32x8x1x2x8xvector<8xf16>, #gpu.address_space<workgroup>>
  %59 = rock.transform %58 by <affine_map<(d0, d1) -> (d0 floordiv 8, d0 mod 8, 0, d1 floordiv 8, d1 mod 8)> by [<Merge{32, 8} ["tid"] at [0] -> ["n_thread", "k_thread"] at [0, 1]>, <Merge{1, 2, 8} ["iter"] at [1] -> ["kouterPerThread", "n_iter", "kpackPerThread"] at [2, 3, 4]>] bounds = [256, 16] -> [32, 8, 1, 2, 8]> : memref<32x8x1x2x8xvector<8xf16>, #gpu.address_space<workgroup>> to memref<256x16xvector<8xf16>, #gpu.address_space<workgroup>>
  rock.threadwise_write_all features =  mfma|dot|atomic_add|atomic_add_f16 {forceUnroll, useIndexDiffs} %32 -> [](%59) [%18] by  set : memref<16xf16, #gpu.address_space<private>> -> memref<256x16xvector<8xf16>, #gpu.address_space<workgroup>>
  scf.for %arg5 = %c0 to %c9 step %c1 {
    %75 = arith.addi %arg5, %c1 : index
    %76 = arith.addi %arg5, %c1 : index
    %77 = rock.threadwise_read_into {forceUnroll, useIndexDiffs} [](%14) [%75, %21, %28, %30, %18] -> %19 : memref<10x1x20x128x256x16xf16> -> memref<16xf16, #gpu.address_space<private>>, vector<16xi1>
    %78 = rock.threadwise_read_into {forceUnroll, useIndexDiffs} [](%16) [%76, %21, %28, %30, %18] -> %20 : memref<10x1x20x128x256x16xf16> -> memref<16xf16, #gpu.address_space<private>>, vector<16xi1>
    %79 = rock.workitem_id : index
    rock.lds_barrier
    affine.for %arg6 = 0 to 1 {
      %96 = rock.extract_multibuffer(%view_5) [%arg5](memref<512xvector<8xf16>, #gpu.address_space<workgroup>>) : memref<512xvector<8xf16>, #gpu.address_space<workgroup>>
      %97 = rock.transform %96 by <affine_map<(d0, d1) -> (d1 * 64 + d0)> by [<Unmerge{8, 64} ["k", "d"] at [1, 0] -> ["source_offset"] at [0]>] bounds = [64, 8] -> [512]> : memref<512xvector<8xf16>, #gpu.address_space<workgroup>> to memref<64x8xvector<8xf16>, #gpu.address_space<workgroup>>
      %98 = rock.transform %97 by <affine_map<(d0, d1) -> (d0 mod 64, d1)> by [<Broadcast{64} ["d"] at [0] -> ["d"] at [0]>, <PassThrough ["k"] at [1] -> ["k"] at [1]>] bounds = [512, 8] -> [64, 8]> : memref<64x8xvector<8xf16>, #gpu.address_space<workgroup>> to memref<512x8xvector<8xf16>, #gpu.address_space<workgroup>>
      %99 = rock.transform %98 by <affine_map<(d0, d1) -> (d1 + d0, d1)> by [<Embed{1, 1} ["k", "d"] at [1, 0] -> ["d"] at [0]>, <PassThrough ["k"] at [1] -> ["k"] at [1]>] bounds = [64, 8] -> [512, 8]> : memref<512x8xvector<8xf16>, #gpu.address_space<workgroup>> to memref<64x8xvector<8xf16>, #gpu.address_space<workgroup>>
      %100 = rock.transform %99 by <affine_map<(d0, d1, d2, d3, d4, d5) -> ((d4 * 2 + d0) * 32 + d3, d2 * 4 + d5)> by [<Unmerge{1, 2, 32} ["d_iter", "wave_m", "blk_td"] at [4, 0, 3] -> ["d"] at [0]>, <Unmerge{2, 4} ["blk_id", "k_iter"] at [2, 5] -> ["k"] at [1]>, <AddDim{2} ["wave_n"] at [1] -> [] at []>] bounds = [2, 2, 2, 32, 1, 4] -> [64, 8]> : memref<64x8xvector<8xf16>, #gpu.address_space<workgroup>> to memref<2x2x2x32x1x4xvector<8xf16>, #gpu.address_space<workgroup>>
      %101 = rock.transform %100 by <affine_map<(d0, d1, d2, d3, d4) -> (d0 floordiv 2, d0 mod 2, d1, d2, d3, d4)> by [<Merge{2, 2} ["wave_id"] at [0] -> ["wave_m", "wave_n"] at [0, 1]>, <PassThrough ["blk_id", "blk_td", "d_iter", "k_iter"] at [1, 2, 3, 4] -> ["blk_id", "blk_td", "d_iter", "k_iter"] at [2, 3, 4, 5]>] bounds = [4, 2, 32, 1, 4] -> [2, 2, 2, 32, 1, 4]> : memref<2x2x2x32x1x4xvector<8xf16>, #gpu.address_space<workgroup>> to memref<4x2x32x1x4xvector<8xf16>, #gpu.address_space<workgroup>>
      %102 = rock.transform %101 by <affine_map<(d0, d1, d2) -> (d0 floordiv 64, (d0 mod 64) floordiv 32, d0 mod 32, d1, d2)> by [<Merge{4, 2, 32} ["tid"] at [0] -> ["wave_id", "blk_id", "blk_td"] at [0, 1, 2]>, <PassThrough ["d_iter", "k_iter"] at [1, 2] -> ["d_iter", "k_iter"] at [3, 4]>] bounds = [256, 1, 4] -> [4, 2, 32, 1, 4]> : memref<4x2x32x1x4xvector<8xf16>, #gpu.address_space<workgroup>> to memref<256x1x4xvector<8xf16>, #gpu.address_space<workgroup>>
      rock.threadwise_read_into {forceUnroll, useIndexDiffs} [](%102) [%79, %arg6] -> %41 : memref<256x1x4xvector<8xf16>, #gpu.address_space<workgroup>> -> memref<8xvector<4xf16>, #gpu.address_space<private>>
      affine.for %arg7 = 0 to 1 {
        %103 = rock.extract_multibuffer(%view_6) [%arg5](memref<512xvector<8xf16>, #gpu.address_space<workgroup>>) : memref<512xvector<8xf16>, #gpu.address_space<workgroup>>
        %104 = rock.transform %103 by <affine_map<(d0, d1) -> (d1 * 64 + d0)> by [<Unmerge{8, 64} ["k", "d"] at [1, 0] -> ["source_offset"] at [0]>] bounds = [64, 8] -> [512]> : memref<512xvector<8xf16>, #gpu.address_space<workgroup>> to memref<64x8xvector<8xf16>, #gpu.address_space<workgroup>>
        %105 = rock.transform %104 by <affine_map<(d0, d1) -> (d0 mod 64, d1)> by [<Broadcast{64} ["d"] at [0] -> ["d"] at [0]>, <PassThrough ["k"] at [1] -> ["k"] at [1]>] bounds = [512, 8] -> [64, 8]> : memref<64x8xvector<8xf16>, #gpu.address_space<workgroup>> to memref<512x8xvector<8xf16>, #gpu.address_space<workgroup>>
        %106 = rock.transform %105 by <affine_map<(d0, d1) -> (d1 + d0, d1)> by [<Embed{1, 1} ["k", "d"] at [1, 0] -> ["d"] at [0]>, <PassThrough ["k"] at [1] -> ["k"] at [1]>] bounds = [64, 8] -> [512, 8]> : memref<512x8xvector<8xf16>, #gpu.address_space<workgroup>> to memref<64x8xvector<8xf16>, #gpu.address_space<workgroup>>
        %107 = rock.transform %106 by <affine_map<(d0, d1, d2, d3, d4, d5) -> ((d4 * 2 + d1) * 32 + d3, d2 * 4 + d5)> by [<Unmerge{1, 2, 32} ["d_iter", "wave_n", "blk_td"] at [4, 1, 3] -> ["d"] at [0]>, <Unmerge{2, 4} ["blk_id", "k_iter"] at [2, 5] -> ["k"] at [1]>, <AddDim{2} ["wave_m"] at [0] -> [] at []>] bounds = [2, 2, 2, 32, 1, 4] -> [64, 8]> : memref<64x8xvector<8xf16>, #gpu.address_space<workgroup>> to memref<2x2x2x32x1x4xvector<8xf16>, #gpu.address_space<workgroup>>
        %108 = rock.transform %107 by <affine_map<(d0, d1, d2, d3, d4) -> (d0 floordiv 2, d0 mod 2, d1, d2, d3, d4)> by [<Merge{2, 2} ["wave_id"] at [0] -> ["wave_m", "wave_n"] at [0, 1]>, <PassThrough ["blk_id", "blk_td", "d_iter", "k_iter"] at [1, 2, 3, 4] -> ["blk_id", "blk_td", "d_iter", "k_iter"] at [2, 3, 4, 5]>] bounds = [4, 2, 32, 1, 4] -> [2, 2, 2, 32, 1, 4]> : memref<2x2x2x32x1x4xvector<8xf16>, #gpu.address_space<workgroup>> to memref<4x2x32x1x4xvector<8xf16>, #gpu.address_space<workgroup>>
        %109 = rock.transform %108 by <affine_map<(d0, d1, d2) -> (d0 floordiv 64, (d0 mod 64) floordiv 32, d0 mod 32, d1, d2)> by [<Merge{4, 2, 32} ["tid"] at [0] -> ["wave_id", "blk_id", "blk_td"] at [0, 1, 2]>, <PassThrough ["d_iter", "k_iter"] at [1, 2] -> ["d_iter", "k_iter"] at [3, 4]>] bounds = [256, 1, 4] -> [4, 2, 32, 1, 4]> : memref<4x2x32x1x4xvector<8xf16>, #gpu.address_space<workgroup>> to memref<256x1x4xvector<8xf16>, #gpu.address_space<workgroup>>
        rock.threadwise_read_into {forceUnroll, useIndexDiffs} [](%109) [%79, %arg7] -> %42 : memref<256x1x4xvector<8xf16>, #gpu.address_space<workgroup>> -> memref<8xvector<4xf16>, #gpu.address_space<private>>
        affine.for %arg8 = 0 to 8 {
          %110 = rock.transform %41 by <affine_map<(d0, d1) -> (d1)> by [<AddDim{1} ["i"] at [0] -> [] at []>, <PassThrough ["k"] at [1] -> ["k"] at [0]>] bounds = [1, 8] -> [8]> : memref<8xvector<4xf16>, #gpu.address_space<private>> to memref<1x8xvector<4xf16>, #gpu.address_space<private>>
          %111 = rock.transform %42 by <affine_map<(d0, d1) -> (d1)> by [<AddDim{1} ["j"] at [0] -> [] at []>, <PassThrough ["k"] at [1] -> ["k"] at [0]>] bounds = [1, 8] -> [8]> : memref<8xvector<4xf16>, #gpu.address_space<private>> to memref<1x8xvector<4xf16>, #gpu.address_space<private>>
          %112 = rock.transform %43 by <affine_map<(d0, d1) -> (d0 + d1)> by [<Unmerge{1, 1} ["i", "j"] at [0, 1] -> ["offset"] at [0]>] bounds = [1, 1] -> [1]> : memref<1xvector<16xf32>, #gpu.address_space<private>> to memref<1x1xvector<16xf32>, #gpu.address_space<private>>
          rock.threadwise_accel_gemm %112 += %110 * %111 at[%arg6, %arg7, %arg8] features =  mfma|dot|atomic_add|atomic_add_f16 {arch = "gfx90a:sramecc+:xnack-", params = #rock.xdlops_gemm_derived_params<kpackPerBlock = 8, mPerBlock = 64, nPerBlock = 64, kpack = 8, mPerWave = 32, nPerWave = 32, mnPerXdl = 32, splitKFactor = 1, forceUnroll = true>} : memref<1x1xvector<16xf32>, #gpu.address_space<private>> += memref<1x8xvector<4xf16>, #gpu.address_space<private>> * memref<1x8xvector<4xf16>, #gpu.address_space<private>>
        }
      }
    }
    %80 = arith.addi %arg5, %c1 : index
    %81 = arith.addi %arg5, %c1 : index
    rock.threadwise_copy %34 -> %36 : memref<8x2xf16, #gpu.address_space<private>> -> memref<8x2xf16, #gpu.address_space<private>>
    rock.threadwise_copy %38 -> %40 : memref<8x2xf16, #gpu.address_space<private>> -> memref<8x2xf16, #gpu.address_space<private>>
    rock.lds_barrier
    %82 = rock.extract_multibuffer(%view_3) [%80](memref<512xvector<8xf16>, #gpu.address_space<workgroup>>) : memref<512xvector<8xf16>, #gpu.address_space<workgroup>>
    %83 = rock.transform %82 by <affine_map<(d0, d1, d2, d3) -> (d0 * 64 + d1 + d2)> by [<Unmerge{8, 64, 1} ["k_outer", "m", "kpack_idx"] at [0, 1, 2] -> ["raw"] at [0]>, <AddDim{8} ["kpack_vec"] at [3] -> [] at []>] bounds = [8, 64, 1, 8] -> [512]> : memref<512xvector<8xf16>, #gpu.address_space<workgroup>> to memref<8x64x1x8xvector<8xf16>, #gpu.address_space<workgroup>>
    %84 = rock.transform %83 by <affine_map<(d0, d1, d2, d3) -> (d0, d1 mod 64, d2, d3)> by [<PassThrough ["k_outer"] at [0] -> ["k_outer"] at [0]>, <Broadcast{64} ["m"] at [1] -> ["m"] at [1]>, <PassThrough ["kpack_idx", "kpack_vec"] at [2, 3] -> ["kpack_idx", "kpack_vec"] at [2, 3]>] bounds = [8, 512, 1, 8] -> [8, 64, 1, 8]> : memref<8x64x1x8xvector<8xf16>, #gpu.address_space<workgroup>> to memref<8x512x1x8xvector<8xf16>, #gpu.address_space<workgroup>>
    %85 = rock.transform %84 by <affine_map<(d0, d1, d2, d3) -> (d0, d0 + d1, d2, d3)> by [<PassThrough ["k_outer"] at [0] -> ["k_outer"] at [0]>, <Embed{1, 1} ["k_outer", "m"] at [0, 1] -> ["m"] at [1]>, <PassThrough ["kpack_idx", "kpack_vec"] at [2, 3] -> ["kpack_idx", "kpack_vec"] at [2, 3]>] bounds = [8, 64, 1, 8] -> [8, 512, 1, 8]> : memref<8x512x1x8xvector<8xf16>, #gpu.address_space<workgroup>> to memref<8x64x1x8xvector<8xf16>, #gpu.address_space<workgroup>>
    %86 = rock.transform %85 by <affine_map<(d0, d1) -> (d0 floordiv 8, d1, 0, d0 mod 8)> by [<Merge{8, 1, 8} ["k"] at [0] -> ["k_outer", "kpack_idx", "kpack_vec"] at [0, 2, 3]>, <Merge{64} ["d"] at [1] -> ["m"] at [1]>] bounds = [64, 64] -> [8, 64, 1, 8]> : memref<8x64x1x8xvector<8xf16>, #gpu.address_space<workgroup>> to memref<64x64xvector<8xf16>, #gpu.address_space<workgroup>>
    %87 = rock.transform %86 by <affine_map<(d0, d1, d2, d3, d4) -> ((d1 + d2) * 8 + d4, d0 * 2 + d3)> by [<Unmerge{8, 1, 8} ["k_thread", "kouterPerThread", "kpackPerThread"] at [1, 2, 4] -> ["k"] at [0]>, <Unmerge{32, 2} ["m_thread", "m_iter"] at [0, 3] -> ["m"] at [1]>] bounds = [32, 8, 1, 2, 8] -> [64, 64]> : memref<64x64xvector<8xf16>, #gpu.address_space<workgroup>> to memref<32x8x1x2x8xvector<8xf16>, #gpu.address_space<workgroup>>
    %88 = rock.transform %87 by <affine_map<(d0, d1) -> (d0 floordiv 8, d0 mod 8, 0, d1 floordiv 8, d1 mod 8)> by [<Merge{32, 8} ["tid"] at [0] -> ["m_thread", "k_thread"] at [0, 1]>, <Merge{1, 2, 8} ["iter"] at [1] -> ["kouterPerThread", "m_iter", "kpackPerThread"] at [2, 3, 4]>] bounds = [256, 16] -> [32, 8, 1, 2, 8]> : memref<32x8x1x2x8xvector<8xf16>, #gpu.address_space<workgroup>> to memref<256x16xvector<8xf16>, #gpu.address_space<workgroup>>
    rock.threadwise_write_all features =  mfma|dot|atomic_add|atomic_add_f16 {forceUnroll, useIndexDiffs} %31 -> [](%88) [%18] by  set : memref<16xf16, #gpu.address_space<private>> -> memref<256x16xvector<8xf16>, #gpu.address_space<workgroup>>
    %89 = rock.extract_multibuffer(%view_4) [%81](memref<512xvector<8xf16>, #gpu.address_space<workgroup>>) : memref<512xvector<8xf16>, #gpu.address_space<workgroup>>
    %90 = rock.transform %89 by <affine_map<(d0, d1, d2, d3) -> (d0 * 64 + d1 + d2)> by [<Unmerge{8, 64, 1} ["k_outer", "n", "kpack_idx"] at [0, 1, 2] -> ["raw"] at [0]>, <AddDim{8} ["kpack_vec"] at [3] -> [] at []>] bounds = [8, 64, 1, 8] -> [512]> : memref<512xvector<8xf16>, #gpu.address_space<workgroup>> to memref<8x64x1x8xvector<8xf16>, #gpu.address_space<workgroup>>
    %91 = rock.transform %90 by <affine_map<(d0, d1, d2, d3) -> (d0, d1 mod 64, d2, d3)> by [<PassThrough ["k_outer"] at [0] -> ["k_outer"] at [0]>, <Broadcast{64} ["n"] at [1] -> ["n"] at [1]>, <PassThrough ["kpack_idx", "kpack_vec"] at [2, 3] -> ["kpack_idx", "kpack_vec"] at [2, 3]>] bounds = [8, 512, 1, 8] -> [8, 64, 1, 8]> : memref<8x64x1x8xvector<8xf16>, #gpu.address_space<workgroup>> to memref<8x512x1x8xvector<8xf16>, #gpu.address_space<workgroup>>
    %92 = rock.transform %91 by <affine_map<(d0, d1, d2, d3) -> (d0, d0 + d1, d2, d3)> by [<PassThrough ["k_outer"] at [0] -> ["k_outer"] at [0]>, <Embed{1, 1} ["k_outer", "n"] at [0, 1] -> ["n"] at [1]>, <PassThrough ["kpack_idx", "kpack_vec"] at [2, 3] -> ["kpack_idx", "kpack_vec"] at [2, 3]>] bounds = [8, 64, 1, 8] -> [8, 512, 1, 8]> : memref<8x512x1x8xvector<8xf16>, #gpu.address_space<workgroup>> to memref<8x64x1x8xvector<8xf16>, #gpu.address_space<workgroup>>
    %93 = rock.transform %92 by <affine_map<(d0, d1) -> (d0 floordiv 8, d1, 0, d0 mod 8)> by [<Merge{8, 1, 8} ["k"] at [0] -> ["k_outer", "kpack_idx", "kpack_vec"] at [0, 2, 3]>, <Merge{64} ["d"] at [1] -> ["n"] at [1]>] bounds = [64, 64] -> [8, 64, 1, 8]> : memref<8x64x1x8xvector<8xf16>, #gpu.address_space<workgroup>> to memref<64x64xvector<8xf16>, #gpu.address_space<workgroup>>
    %94 = rock.transform %93 by <affine_map<(d0, d1, d2, d3, d4) -> ((d1 + d2) * 8 + d4, d0 * 2 + d3)> by [<Unmerge{8, 1, 8} ["k_thread", "kouterPerThread", "kpackPerThread"] at [1, 2, 4] -> ["k"] at [0]>, <Unmerge{32, 2} ["n_thread", "n_iter"] at [0, 3] -> ["n"] at [1]>] bounds = [32, 8, 1, 2, 8] -> [64, 64]> : memref<64x64xvector<8xf16>, #gpu.address_space<workgroup>> to memref<32x8x1x2x8xvector<8xf16>, #gpu.address_space<workgroup>>
    %95 = rock.transform %94 by <affine_map<(d0, d1) -> (d0 floordiv 8, d0 mod 8, 0, d1 floordiv 8, d1 mod 8)> by [<Merge{32, 8} ["tid"] at [0] -> ["n_thread", "k_thread"] at [0, 1]>, <Merge{1, 2, 8} ["iter"] at [1] -> ["kouterPerThread", "n_iter", "kpackPerThread"] at [2, 3, 4]>] bounds = [256, 16] -> [32, 8, 1, 2, 8]> : memref<32x8x1x2x8xvector<8xf16>, #gpu.address_space<workgroup>> to memref<256x16xvector<8xf16>, #gpu.address_space<workgroup>>
    rock.threadwise_write_all features =  mfma|dot|atomic_add|atomic_add_f16 {forceUnroll, useIndexDiffs} %32 -> [](%95) [%18] by  set : memref<16xf16, #gpu.address_space<private>> -> memref<256x16xvector<8xf16>, #gpu.address_space<workgroup>>
  }
  %60 = rock.workitem_id : index
  rock.lds_barrier
  affine.for %arg5 = 0 to 1 {
    %75 = rock.extract_multibuffer(%view_5) [%c9](memref<512xvector<8xf16>, #gpu.address_space<workgroup>>) : memref<512xvector<8xf16>, #gpu.address_space<workgroup>>
    %76 = rock.transform %75 by <affine_map<(d0, d1) -> (d1 * 64 + d0)> by [<Unmerge{8, 64} ["k", "d"] at [1, 0] -> ["source_offset"] at [0]>] bounds = [64, 8] -> [512]> : memref<512xvector<8xf16>, #gpu.address_space<workgroup>> to memref<64x8xvector<8xf16>, #gpu.address_space<workgroup>>
    %77 = rock.transform %76 by <affine_map<(d0, d1) -> (d0 mod 64, d1)> by [<Broadcast{64} ["d"] at [0] -> ["d"] at [0]>, <PassThrough ["k"] at [1] -> ["k"] at [1]>] bounds = [512, 8] -> [64, 8]> : memref<64x8xvector<8xf16>, #gpu.address_space<workgroup>> to memref<512x8xvector<8xf16>, #gpu.address_space<workgroup>>
    %78 = rock.transform %77 by <affine_map<(d0, d1) -> (d1 + d0, d1)> by [<Embed{1, 1} ["k", "d"] at [1, 0] -> ["d"] at [0]>, <PassThrough ["k"] at [1] -> ["k"] at [1]>] bounds = [64, 8] -> [512, 8]> : memref<512x8xvector<8xf16>, #gpu.address_space<workgroup>> to memref<64x8xvector<8xf16>, #gpu.address_space<workgroup>>
    %79 = rock.transform %78 by <affine_map<(d0, d1, d2, d3, d4, d5) -> ((d4 * 2 + d0) * 32 + d3, d2 * 4 + d5)> by [<Unmerge{1, 2, 32} ["d_iter", "wave_m", "blk_td"] at [4, 0, 3] -> ["d"] at [0]>, <Unmerge{2, 4} ["blk_id", "k_iter"] at [2, 5] -> ["k"] at [1]>, <AddDim{2} ["wave_n"] at [1] -> [] at []>] bounds = [2, 2, 2, 32, 1, 4] -> [64, 8]> : memref<64x8xvector<8xf16>, #gpu.address_space<workgroup>> to memref<2x2x2x32x1x4xvector<8xf16>, #gpu.address_space<workgroup>>
    %80 = rock.transform %79 by <affine_map<(d0, d1, d2, d3, d4) -> (d0 floordiv 2, d0 mod 2, d1, d2, d3, d4)> by [<Merge{2, 2} ["wave_id"] at [0] -> ["wave_m", "wave_n"] at [0, 1]>, <PassThrough ["blk_id", "blk_td", "d_iter", "k_iter"] at [1, 2, 3, 4] -> ["blk_id", "blk_td", "d_iter", "k_iter"] at [2, 3, 4, 5]>] bounds = [4, 2, 32, 1, 4] -> [2, 2, 2, 32, 1, 4]> : memref<2x2x2x32x1x4xvector<8xf16>, #gpu.address_space<workgroup>> to memref<4x2x32x1x4xvector<8xf16>, #gpu.address_space<workgroup>>
    %81 = rock.transform %80 by <affine_map<(d0, d1, d2) -> (d0 floordiv 64, (d0 mod 64) floordiv 32, d0 mod 32, d1, d2)> by [<Merge{4, 2, 32} ["tid"] at [0] -> ["wave_id", "blk_id", "blk_td"] at [0, 1, 2]>, <PassThrough ["d_iter", "k_iter"] at [1, 2] -> ["d_iter", "k_iter"] at [3, 4]>] bounds = [256, 1, 4] -> [4, 2, 32, 1, 4]> : memref<4x2x32x1x4xvector<8xf16>, #gpu.address_space<workgroup>> to memref<256x1x4xvector<8xf16>, #gpu.address_space<workgroup>>
    rock.threadwise_read_into {forceUnroll, useIndexDiffs} [](%81) [%60, %arg5] -> %41 : memref<256x1x4xvector<8xf16>, #gpu.address_space<workgroup>> -> memref<8xvector<4xf16>, #gpu.address_space<private>>
    affine.for %arg6 = 0 to 1 {
      %82 = rock.extract_multibuffer(%view_6) [%c9](memref<512xvector<8xf16>, #gpu.address_space<workgroup>>) : memref<512xvector<8xf16>, #gpu.address_space<workgroup>>
      %83 = rock.transform %82 by <affine_map<(d0, d1) -> (d1 * 64 + d0)> by [<Unmerge{8, 64} ["k", "d"] at [1, 0] -> ["source_offset"] at [0]>] bounds = [64, 8] -> [512]> : memref<512xvector<8xf16>, #gpu.address_space<workgroup>> to memref<64x8xvector<8xf16>, #gpu.address_space<workgroup>>
      %84 = rock.transform %83 by <affine_map<(d0, d1) -> (d0 mod 64, d1)> by [<Broadcast{64} ["d"] at [0] -> ["d"] at [0]>, <PassThrough ["k"] at [1] -> ["k"] at [1]>] bounds = [512, 8] -> [64, 8]> : memref<64x8xvector<8xf16>, #gpu.address_space<workgroup>> to memref<512x8xvector<8xf16>, #gpu.address_space<workgroup>>
      %85 = rock.transform %84 by <affine_map<(d0, d1) -> (d1 + d0, d1)> by [<Embed{1, 1} ["k", "d"] at [1, 0] -> ["d"] at [0]>, <PassThrough ["k"] at [1] -> ["k"] at [1]>] bounds = [64, 8] -> [512, 8]> : memref<512x8xvector<8xf16>, #gpu.address_space<workgroup>> to memref<64x8xvector<8xf16>, #gpu.address_space<workgroup>>
      %86 = rock.transform %85 by <affine_map<(d0, d1, d2, d3, d4, d5) -> ((d4 * 2 + d1) * 32 + d3, d2 * 4 + d5)> by [<Unmerge{1, 2, 32} ["d_iter", "wave_n", "blk_td"] at [4, 1, 3] -> ["d"] at [0]>, <Unmerge{2, 4} ["blk_id", "k_iter"] at [2, 5] -> ["k"] at [1]>, <AddDim{2} ["wave_m"] at [0] -> [] at []>] bounds = [2, 2, 2, 32, 1, 4] -> [64, 8]> : memref<64x8xvector<8xf16>, #gpu.address_space<workgroup>> to memref<2x2x2x32x1x4xvector<8xf16>, #gpu.address_space<workgroup>>
      %87 = rock.transform %86 by <affine_map<(d0, d1, d2, d3, d4) -> (d0 floordiv 2, d0 mod 2, d1, d2, d3, d4)> by [<Merge{2, 2} ["wave_id"] at [0] -> ["wave_m", "wave_n"] at [0, 1]>, <PassThrough ["blk_id", "blk_td", "d_iter", "k_iter"] at [1, 2, 3, 4] -> ["blk_id", "blk_td", "d_iter", "k_iter"] at [2, 3, 4, 5]>] bounds = [4, 2, 32, 1, 4] -> [2, 2, 2, 32, 1, 4]> : memref<2x2x2x32x1x4xvector<8xf16>, #gpu.address_space<workgroup>> to memref<4x2x32x1x4xvector<8xf16>, #gpu.address_space<workgroup>>
      %88 = rock.transform %87 by <affine_map<(d0, d1, d2) -> (d0 floordiv 64, (d0 mod 64) floordiv 32, d0 mod 32, d1, d2)> by [<Merge{4, 2, 32} ["tid"] at [0] -> ["wave_id", "blk_id", "blk_td"] at [0, 1, 2]>, <PassThrough ["d_iter", "k_iter"] at [1, 2] -> ["d_iter", "k_iter"] at [3, 4]>] bounds = [256, 1, 4] -> [4, 2, 32, 1, 4]> : memref<4x2x32x1x4xvector<8xf16>, #gpu.address_space<workgroup>> to memref<256x1x4xvector<8xf16>, #gpu.address_space<workgroup>>
      rock.threadwise_read_into {forceUnroll, useIndexDiffs} [](%88) [%60, %arg6] -> %42 : memref<256x1x4xvector<8xf16>, #gpu.address_space<workgroup>> -> memref<8xvector<4xf16>, #gpu.address_space<private>>
      affine.for %arg7 = 0 to 8 {
        %89 = rock.transform %41 by <affine_map<(d0, d1) -> (d1)> by [<AddDim{1} ["i"] at [0] -> [] at []>, <PassThrough ["k"] at [1] -> ["k"] at [0]>] bounds = [1, 8] -> [8]> : memref<8xvector<4xf16>, #gpu.address_space<private>> to memref<1x8xvector<4xf16>, #gpu.address_space<private>>
        %90 = rock.transform %42 by <affine_map<(d0, d1) -> (d1)> by [<AddDim{1} ["j"] at [0] -> [] at []>, <PassThrough ["k"] at [1] -> ["k"] at [0]>] bounds = [1, 8] -> [8]> : memref<8xvector<4xf16>, #gpu.address_space<private>> to memref<1x8xvector<4xf16>, #gpu.address_space<private>>
        %91 = rock.transform %43 by <affine_map<(d0, d1) -> (d0 + d1)> by [<Unmerge{1, 1} ["i", "j"] at [0, 1] -> ["offset"] at [0]>] bounds = [1, 1] -> [1]> : memref<1xvector<16xf32>, #gpu.address_space<private>> to memref<1x1xvector<16xf32>, #gpu.address_space<private>>
        rock.threadwise_accel_gemm %91 += %89 * %90 at[%arg5, %arg6, %arg7] features =  mfma|dot|atomic_add|atomic_add_f16 {arch = "gfx90a:sramecc+:xnack-", params = #rock.xdlops_gemm_derived_params<kpackPerBlock = 8, mPerBlock = 64, nPerBlock = 64, kpack = 8, mPerWave = 32, nPerWave = 32, mnPerXdl = 32, splitKFactor = 1, forceUnroll = true>} : memref<1x1xvector<16xf32>, #gpu.address_space<private>> += memref<1x8xvector<4xf16>, #gpu.address_space<private>> * memref<1x8xvector<4xf16>, #gpu.address_space<private>>
      }
    }
  }
  rock.dealloc %0 : memref<8192xi8, #gpu.address_space<workgroup>>
  rock.dealloc %1 : memref<8192xi8, #gpu.address_space<workgroup>>
  %61 = rock.alloc() : memref<16xf32, #gpu.address_space<private>>
  rock.transforming_for {forceUnroll, useIndexDiffs} (%arg5) = [](%c0), (%arg6) = [#rock.transform_map<affine_map<(d0) -> (d0 * 16)> by [<Embed{16} ["vector"] at [0] -> ["scalar"] at [0]>] bounds = [1] -> [16]>](%c0) (%arg7, %arg8) = validity bounds [1] strides [1] {
    %75 = memref.load %43[%arg5] : memref<1xvector<16xf32>, #gpu.address_space<private>>
    rock.in_bounds_store %75 -> %61[%arg6] : vector<16xf32> -> memref<16xf32, #gpu.address_space<private>>, index
    rock.yield
  }
  %62 = rock.alloc() : memref<16xf16, #gpu.address_space<private>>
  affine.for %arg5 = 0 to 16 step 2 {
    %cst_7 = arith.constant 0.000000e+00 : f32
    %75 = vector.transfer_read %61[%arg5], %cst_7 {in_bounds = [true]} : memref<16xf32, #gpu.address_space<private>>, vector<2xf32>
    %76 = arith.truncf %75 : vector<2xf32> to vector<2xf16>
    vector.transfer_write %76, %62[%arg5] {in_bounds = [true]} : vector<2xf16>, memref<16xf16, #gpu.address_space<private>>
  }
  %63 = rock.alloc() : memref<16xf16, #gpu.address_space<private>>
  %64 = rock.alloc() : memref<16xf16, #gpu.address_space<private>>
  %65 = rock.transform %4 by <affine_map<(d0, d1, d2, d3, d4) -> (d0, d1 * 1280 + d2, d3, d4)> by [<PassThrough ["n", "h", "w"] at [0, 3, 4] -> ["n", "h", "w"] at [0, 2, 3]>, <Unmerge{1, 1280} ["g", "k"] at [1, 2] -> ["k"] at [1]>] bounds = [2, 1, 1280, 64, 64] -> [2, 1280, 64, 64]> : memref<2x1280x64x64xf16> to memref<2x1x1280x64x64xf16>
  %66 = rock.transform %65 by <affine_map<(d0, d1, d2) -> (d2 floordiv 4096, d0, d1, (d2 mod 4096) floordiv 64, d2 mod 64)> by [<PassThrough ["gemmG"] at [0] -> ["go"] at [1]>, <PassThrough ["gemmM"] at [1] -> ["ko"] at [2]>, <Merge{2, 64, 64} ["gemmN"] at [2] -> ["no", "0o", "1o"] at [0, 3, 4]>] bounds = [1, 1280, 8192] -> [2, 1, 1280, 64, 64]> : memref<2x1x1280x64x64xf16> to memref<1x1280x8192xf16>
  rock.threadwise_read_into {forceUnroll, useIndexDiffs} [#rock.transform_map<affine_map<(d0, d1, d2, d3, d4) -> (d0, d1, d2, d3 floordiv 64, (d3 mod 64) floordiv 32, d3 mod 32, 0, 0, d4 floordiv 4, d4 mod 4)> by [<PassThrough ["g_block", "m_block", "n_block"] at [0, 1, 2] -> ["g_block", "m_block", "n_block"] at [0, 1, 2]>, <Merge{4, 2, 32} ["tid"] at [3] -> ["wave", "m_tid", "n_tid"] at [3, 4, 5]>, <Merge{1, 1, 4, 4} ["item"] at [4] -> ["i", "j", "vec_group", "vec_item"] at [6, 7, 8, 9]>] bounds = [1, 20, 128, 256, 16] -> [1, 20, 128, 4, 2, 32, 1, 1, 4, 4]>, #rock.transform_map<affine_map<(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9) -> (d0, d1, d2, d3 floordiv 2, d3 mod 2, d4, d5, 0, 0, 0, 0, d8, d9)> by [<PassThrough ["g_block", "m_block", "n_block"] at [0, 1, 2] -> ["g_block", "m_block", "n_block"] at [0, 1, 2]>, <Merge{2, 2} ["wave"] at [3] -> ["wave_m", "wave_n"] at [3, 4]>, <PassThrough ["m_tid", "n_tid"] at [4, 5] -> ["m_tid", "n_tid"] at [5, 6]>, <Merge{1, 1} ["i"] at [6] -> ["m_i", "n_i"] at [7, 8]>, <Merge{1, 1} ["j"] at [7] -> ["blk_row", "blk_col"] at [9, 10]>, <PassThrough ["vec_group", "vec_item"] at [8, 9] -> ["vec_group", "vec_item"] at [11, 12]>] bounds = [1, 20, 128, 4, 2, 32, 1, 1, 4, 4] -> [1, 20, 128, 2, 2, 2, 32, 1, 1, 1, 1, 4, 4]>, #rock.transform_map<affine_map<(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12) -> (d0, d1, d2, (((d7 * 2 + d3 + d9) * 4 + d11) * 2 + d5) * 4 + d12, (d8 * 2 + d4 + d10) * 32 + d6)> by [<PassThrough ["g_block", "m_block", "n_block"] at [0, 1, 2] -> ["g_block", "m_block", "n_block"] at [0, 1, 2]>, <Unmerge{1, 2, 1, 4, 2, 4} ["m_i", "wave_m", "blk_row", "vec_group", "m_tid", "vec_item"] at [7, 3, 9, 11, 5, 12] -> ["gemmBlockM"] at [3]>, <Unmerge{1, 2, 1, 32} ["n_i", "wave_n", "blk_col", "n_tid"] at [8, 4, 10, 6] -> ["gemmBlockN"] at [4]>] bounds = [1, 20, 128, 2, 2, 2, 32, 1, 1, 1, 1, 4, 4] -> [1, 20, 128, 64, 64]>, #rock.transform_map<affine_map<(d0, d1, d2, d3, d4) -> (d0, d1, d2, d3, d4)> by [<PassThrough ["g_block", "m_block", "n_block"] at [0, 1, 2] -> ["g_block", "m_block", "n_block"] at [0, 1, 2]>, <PassThrough ["gemmBlockM"] at [3] -> ["gemmBlockM"] at [3]>, <PassThrough ["gemmBlockN"] at [4] -> ["gemmBlockN"] at [4]>] bounds = [1, 20, 128, 64, 64] -> [1, 20, 128, 64, 64]>, #rock.transform_map<affine_map<(d0, d1, d2, d3, d4) -> (d0, d1, d2, d3, d4)> by [<PassThrough ["g_block", "m_block", "n_block"] at [0, 1, 2] -> ["g_block", "m_block", "n_block"] at [0, 1, 2]>, <PassThrough ["gemmBlockM"] at [3] -> ["gemmBlockM"] at [3]>, <PassThrough ["gemmBlockN"] at [4] -> ["gemmBlockN"] at [4]>] bounds = [1, 20, 128, 64, 64] -> [1, 20, 128, 64, 64]>, #rock.transform_map<affine_map<(d0, d1, d2, d3, d4) -> (d0, d1 * 64 + d3, d2 * 64 + d4)> by [<PassThrough ["g_block"] at [0] -> ["gemmG"] at [0]>, <Unmerge{20, 64} ["m_block", "gemmBlockM"] at [1, 3] -> ["gemmM"] at [1]>, <Unmerge{128, 64} ["n_block", "gemmBlockN"] at [2, 4] -> ["gemmN"] at [2]>] bounds = [1, 20, 128, 64, 64] -> [1, 1280, 8192]>](%66) [%21, %28, %30, %18] -> %64 : memref<1x1280x8192xf16> -> memref<16xf16, #gpu.address_space<private>>
  affine.for %arg5 = 0 to 16 step 4 {
    %cst_7 = arith.constant 0.000000e+00 : f16
    %75 = vector.transfer_read %62[%arg5], %cst_7 {in_bounds = [true]} : memref<16xf16, #gpu.address_space<private>>, vector<4xf16>
    %cst_8 = arith.constant 0.000000e+00 : f16
    %76 = vector.transfer_read %64[%arg5], %cst_8 {in_bounds = [true]} : memref<16xf16, #gpu.address_space<private>>, vector<4xf16>
    %77 = arith.addf %75, %76 : vector<4xf16>
    vector.transfer_write %77, %63[%arg5] {in_bounds = [true]} : vector<4xf16>, memref<16xf16, #gpu.address_space<private>>
  }
  %67 = rock.transform %arg3 by <affine_map<(d0, d1, d2, d3) -> (((d0 * 64 + d1) * 64 + d2) * 1280 + d3)> by [<Unmerge{2, 64, 64, 1280} ["col0", "col1", "col2", "col3"] at [0, 1, 2, 3] -> ["dim0"] at [0]>] bounds = [2, 64, 64, 1280] -> [10485760]> : memref<10485760xf16> to memref<2x64x64x1280xf16>
  %68 = rock.transform %67 by <affine_map<(d0, d1, d2, d3) -> (d0, d2, d3, d1)> by [<PassThrough ["dim0", "dim2", "dim3", "dim1"] at [0, 2, 3, 1] -> ["dim0", "dim2", "dim3", "dim1"] at [0, 1, 2, 3]>] bounds = [2, 1280, 64, 64] -> [2, 64, 64, 1280]> : memref<2x64x64x1280xf16> to memref<2x1280x64x64xf16>
  %69 = rock.transform %68 by <affine_map<(d0, d1, d2, d3, d4) -> (d0, d1 * 1280 + d2, d3, d4)> by [<PassThrough ["n", "h", "w"] at [0, 3, 4] -> ["n", "h", "w"] at [0, 2, 3]>, <Unmerge{1, 1280} ["g", "k"] at [1, 2] -> ["k"] at [1]>] bounds = [2, 1, 1280, 64, 64] -> [2, 1280, 64, 64]> : memref<2x1280x64x64xf16> to memref<2x1x1280x64x64xf16>
  %70 = rock.transform %69 by <affine_map<(d0, d1, d2) -> (d2 floordiv 4096, d0, d1, (d2 mod 4096) floordiv 64, d2 mod 64)> by [<PassThrough ["gemmG"] at [0] -> ["go"] at [1]>, <PassThrough ["gemmM"] at [1] -> ["ko"] at [2]>, <Merge{2, 64, 64} ["gemmN"] at [2] -> ["no", "0o", "1o"] at [0, 3, 4]>] bounds = [1, 1280, 8192] -> [2, 1, 1280, 64, 64]> : memref<2x1x1280x64x64xf16> to memref<1x1280x8192xf16>
  
  // CHECK: %[[alloc1:.*]] = rock.alloc() : memref<8192xi8, #gpu.address_space<workgroup>>
  // CHECK: %[[view1:.*]] = memref.view %[[alloc1]]
  // CHECK: %[[transformed1:.*]] = rock.transform %[[view1]]
  // CHECK: rock.threadwise_write_all {{.*}}(%[[transformed1]])
  // CHECK: rock.lds_barrier
  // CHECK: rock.threadwise_read_into
  // CHECK: rock.threadwise_write_all
  rock.threadwise_write_all features =  mfma|dot|atomic_add|atomic_add_f16 {forceUnroll, useIndexDiffs} %62 -> [#rock.transform_map<affine_map<(d0, d1, d2, d3, d4) -> (d0, d1, d2, d3 floordiv 64, (d3 mod 64) floordiv 32, d3 mod 32, 0, 0, d4 floordiv 4, d4 mod 4)> by [<PassThrough ["g_block", "m_block", "n_block"] at [0, 1, 2] -> ["g_block", "m_block", "n_block"] at [0, 1, 2]>, <Merge{4, 2, 32} ["tid"] at [3] -> ["wave", "m_tid", "n_tid"] at [3, 4, 5]>, <Merge{1, 1, 4, 4} ["item"] at [4] -> ["i", "j", "vec_group", "vec_item"] at [6, 7, 8, 9]>] bounds = [1, 20, 128, 256, 16] -> [1, 20, 128, 4, 2, 32, 1, 1, 4, 4]>, #rock.transform_map<affine_map<(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9) -> (d0, d1, d2, d3 floordiv 2, d3 mod 2, d4, d5, 0, 0, 0, 0, d8, d9)> by [<PassThrough ["g_block", "m_block", "n_block"] at [0, 1, 2] -> ["g_block", "m_block", "n_block"] at [0, 1, 2]>, <Merge{2, 2} ["wave"] at [3] -> ["wave_m", "wave_n"] at [3, 4]>, <PassThrough ["m_tid", "n_tid"] at [4, 5] -> ["m_tid", "n_tid"] at [5, 6]>, <Merge{1, 1} ["i"] at [6] -> ["m_i", "n_i"] at [7, 8]>, <Merge{1, 1} ["j"] at [7] -> ["blk_row", "blk_col"] at [9, 10]>, <PassThrough ["vec_group", "vec_item"] at [8, 9] -> ["vec_group", "vec_item"] at [11, 12]>] bounds = [1, 20, 128, 4, 2, 32, 1, 1, 4, 4] -> [1, 20, 128, 2, 2, 2, 32, 1, 1, 1, 1, 4, 4]>, #rock.transform_map<affine_map<(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12) -> (d0, d1, d2, (((d7 * 2 + d3 + d9) * 4 + d11) * 2 + d5) * 4 + d12, (d8 * 2 + d4 + d10) * 32 + d6)> by [<PassThrough ["g_block", "m_block", "n_block"] at [0, 1, 2] -> ["g_block", "m_block", "n_block"] at [0, 1, 2]>, <Unmerge{1, 2, 1, 4, 2, 4} ["m_i", "wave_m", "blk_row", "vec_group", "m_tid", "vec_item"] at [7, 3, 9, 11, 5, 12] -> ["gemmBlockM"] at [3]>, <Unmerge{1, 2, 1, 32} ["n_i", "wave_n", "blk_col", "n_tid"] at [8, 4, 10, 6] -> ["gemmBlockN"] at [4]>] bounds = [1, 20, 128, 2, 2, 2, 32, 1, 1, 1, 1, 4, 4] -> [1, 20, 128, 64, 64]>, #rock.transform_map<affine_map<(d0, d1, d2, d3, d4) -> (d0, d1, d2, d3, d4)> by [<PassThrough ["g_block", "m_block", "n_block"] at [0, 1, 2] -> ["g_block", "m_block", "n_block"] at [0, 1, 2]>, <PassThrough ["gemmBlockM"] at [3] -> ["gemmBlockM"] at [3]>, <PassThrough ["gemmBlockN"] at [4] -> ["gemmBlockN"] at [4]>] bounds = [1, 20, 128, 64, 64] -> [1, 20, 128, 64, 64]>, #rock.transform_map<affine_map<(d0, d1, d2, d3, d4) -> (d0, d1, d2, d3, d4)> by [<PassThrough ["g_block", "m_block", "n_block"] at [0, 1, 2] -> ["g_block", "m_block", "n_block"] at [0, 1, 2]>, <PassThrough ["gemmBlockM"] at [3] -> ["gemmBlockM"] at [3]>, <PassThrough ["gemmBlockN"] at [4] -> ["gemmBlockN"] at [4]>] bounds = [1, 20, 128, 64, 64] -> [1, 20, 128, 64, 64]>, #rock.transform_map<affine_map<(d0, d1, d2, d3, d4) -> (d0, d1 * 64 + d3, d2 * 64 + d4)> by [<PassThrough ["g_block"] at [0] -> ["gemmG"] at [0]>, <Unmerge{20, 64} ["m_block", "gemmBlockM"] at [1, 3] -> ["gemmM"] at [1]>, <Unmerge{128, 64} ["n_block", "gemmBlockN"] at [2, 4] -> ["gemmN"] at [2]>] bounds = [1, 20, 128, 64, 64] -> [1, 1280, 8192]>](%70) [%21, %28, %30, %18] by  set : memref<16xf16, #gpu.address_space<private>> -> memref<1x1280x8192xf16>
  %71 = rock.transform %arg4 by <affine_map<(d0, d1, d2, d3) -> (((d0 * 64 + d1) * 64 + d2) * 1280 + d3)> by [<Unmerge{2, 64, 64, 1280} ["col0", "col1", "col2", "col3"] at [0, 1, 2, 3] -> ["dim0"] at [0]>] bounds = [2, 64, 64, 1280] -> [10485760]> : memref<10485760xf16> to memref<2x64x64x1280xf16>
  %72 = rock.transform %71 by <affine_map<(d0, d1, d2, d3) -> (d0, d2, d3, d1)> by [<PassThrough ["dim0", "dim2", "dim3", "dim1"] at [0, 2, 3, 1] -> ["dim0", "dim2", "dim3", "dim1"] at [0, 1, 2, 3]>] bounds = [2, 1280, 64, 64] -> [2, 64, 64, 1280]> : memref<2x64x64x1280xf16> to memref<2x1280x64x64xf16>
  %73 = rock.transform %72 by <affine_map<(d0, d1, d2, d3, d4) -> (d0, d1 * 1280 + d2, d3, d4)> by [<PassThrough ["n", "h", "w"] at [0, 3, 4] -> ["n", "h", "w"] at [0, 2, 3]>, <Unmerge{1, 1280} ["g", "k"] at [1, 2] -> ["k"] at [1]>] bounds = [2, 1, 1280, 64, 64] -> [2, 1280, 64, 64]> : memref<2x1280x64x64xf16> to memref<2x1x1280x64x64xf16>
  %74 = rock.transform %73 by <affine_map<(d0, d1, d2) -> (d2 floordiv 4096, d0, d1, (d2 mod 4096) floordiv 64, d2 mod 64)> by [<PassThrough ["gemmG"] at [0] -> ["go"] at [1]>, <PassThrough ["gemmM"] at [1] -> ["ko"] at [2]>, <Merge{2, 64, 64} ["gemmN"] at [2] -> ["no", "0o", "1o"] at [0, 3, 4]>] bounds = [1, 1280, 8192] -> [2, 1, 1280, 64, 64]> : memref<2x1x1280x64x64xf16> to memref<1x1280x8192xf16>
  
  // CHECK: %[[alloc2:.*]] = rock.alloc() : memref<8192xi8, #gpu.address_space<workgroup>>
  // CHECK: %[[view2:.*]] = memref.view %[[alloc2]]
  // CHECK: %[[transformed2:.*]] = rock.transform %[[view2]]
  // CHECK: rock.threadwise_write_all {{.*}}(%[[transformed2]])
  // CHECK: rock.lds_barrier
  // CHECK: rock.threadwise_read_into
  // CHECK: rock.threadwise_write_all
  rock.threadwise_write_all features =  mfma|dot|atomic_add|atomic_add_f16 {forceUnroll, useIndexDiffs} %63 -> [#rock.transform_map<affine_map<(d0, d1, d2, d3, d4) -> (d0, d1, d2, d3 floordiv 64, (d3 mod 64) floordiv 32, d3 mod 32, 0, 0, d4 floordiv 4, d4 mod 4)> by [<PassThrough ["g_block", "m_block", "n_block"] at [0, 1, 2] -> ["g_block", "m_block", "n_block"] at [0, 1, 2]>, <Merge{4, 2, 32} ["tid"] at [3] -> ["wave", "m_tid", "n_tid"] at [3, 4, 5]>, <Merge{1, 1, 4, 4} ["item"] at [4] -> ["i", "j", "vec_group", "vec_item"] at [6, 7, 8, 9]>] bounds = [1, 20, 128, 256, 16] -> [1, 20, 128, 4, 2, 32, 1, 1, 4, 4]>, #rock.transform_map<affine_map<(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9) -> (d0, d1, d2, d3 floordiv 2, d3 mod 2, d4, d5, 0, 0, 0, 0, d8, d9)> by [<PassThrough ["g_block", "m_block", "n_block"] at [0, 1, 2] -> ["g_block", "m_block", "n_block"] at [0, 1, 2]>, <Merge{2, 2} ["wave"] at [3] -> ["wave_m", "wave_n"] at [3, 4]>, <PassThrough ["m_tid", "n_tid"] at [4, 5] -> ["m_tid", "n_tid"] at [5, 6]>, <Merge{1, 1} ["i"] at [6] -> ["m_i", "n_i"] at [7, 8]>, <Merge{1, 1} ["j"] at [7] -> ["blk_row", "blk_col"] at [9, 10]>, <PassThrough ["vec_group", "vec_item"] at [8, 9] -> ["vec_group", "vec_item"] at [11, 12]>] bounds = [1, 20, 128, 4, 2, 32, 1, 1, 4, 4] -> [1, 20, 128, 2, 2, 2, 32, 1, 1, 1, 1, 4, 4]>, #rock.transform_map<affine_map<(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12) -> (d0, d1, d2, (((d7 * 2 + d3 + d9) * 4 + d11) * 2 + d5) * 4 + d12, (d8 * 2 + d4 + d10) * 32 + d6)> by [<PassThrough ["g_block", "m_block", "n_block"] at [0, 1, 2] -> ["g_block", "m_block", "n_block"] at [0, 1, 2]>, <Unmerge{1, 2, 1, 4, 2, 4} ["m_i", "wave_m", "blk_row", "vec_group", "m_tid", "vec_item"] at [7, 3, 9, 11, 5, 12] -> ["gemmBlockM"] at [3]>, <Unmerge{1, 2, 1, 32} ["n_i", "wave_n", "blk_col", "n_tid"] at [8, 4, 10, 6] -> ["gemmBlockN"] at [4]>] bounds = [1, 20, 128, 2, 2, 2, 32, 1, 1, 1, 1, 4, 4] -> [1, 20, 128, 64, 64]>, #rock.transform_map<affine_map<(d0, d1, d2, d3, d4) -> (d0, d1, d2, d3, d4)> by [<PassThrough ["g_block", "m_block", "n_block"] at [0, 1, 2] -> ["g_block", "m_block", "n_block"] at [0, 1, 2]>, <PassThrough ["gemmBlockM"] at [3] -> ["gemmBlockM"] at [3]>, <PassThrough ["gemmBlockN"] at [4] -> ["gemmBlockN"] at [4]>] bounds = [1, 20, 128, 64, 64] -> [1, 20, 128, 64, 64]>, #rock.transform_map<affine_map<(d0, d1, d2, d3, d4) -> (d0, d1, d2, d3, d4)> by [<PassThrough ["g_block", "m_block", "n_block"] at [0, 1, 2] -> ["g_block", "m_block", "n_block"] at [0, 1, 2]>, <PassThrough ["gemmBlockM"] at [3] -> ["gemmBlockM"] at [3]>, <PassThrough ["gemmBlockN"] at [4] -> ["gemmBlockN"] at [4]>] bounds = [1, 20, 128, 64, 64] -> [1, 20, 128, 64, 64]>, #rock.transform_map<affine_map<(d0, d1, d2, d3, d4) -> (d0, d1 * 64 + d3, d2 * 64 + d4)> by [<PassThrough ["g_block"] at [0] -> ["gemmG"] at [0]>, <Unmerge{20, 64} ["m_block", "gemmBlockM"] at [1, 3] -> ["gemmM"] at [1]>, <Unmerge{128, 64} ["n_block", "gemmBlockN"] at [2, 4] -> ["gemmN"] at [2]>] bounds = [1, 20, 128, 64, 64] -> [1, 1280, 8192]>](%74) [%21, %28, %30, %18] by  set : memref<16xf16, #gpu.address_space<private>> -> memref<1x1280x8192xf16>
  return
}
